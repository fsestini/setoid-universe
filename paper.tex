\documentclass[a4paper,UKenglish,cleveref, autoref, thm-restate]{lipics-v2019}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{mathpartir}
\usepackage{dsfont}
\usepackage{proof}
\usepackage{bbm}
%\usepackage[bw]{agda}

\bibliographystyle{plainurl}% the mandatory bibstyle

\newcommand{\mlttp}{\textsf{MLTT}^{\mProp}}
\newcommand{\refl}{\textsf{refl}}
\newcommand{\GG}{\Gamma}
\newcommand{\DD}{\Delta}
\newcommand{\GD}{\Delta}
\newcommand{\R}{\textsf{R}}
\newcommand{\Id}{\textsf{Id}}
\newcommand{\coe}{\textsf{coe}}
\newcommand{\coh}{\textsf{coh}}
\newcommand{\J}{\textsf{J}}
\newcommand{\tyj}[2]{#2 : \Ty\ #1}
\newcommand{\tmj}[3]{#2 : \Tm\ #1\ #3}
\newcommand{\subj}[3]{#1 : \mathrm{Sub}\ #2\ #3}
\newcommand{\setoidU}{\mathcal{U}}
% \newcommand{\ad}[1]{\AgdaFunction{#1}}
\newcommand{\inU}{\mathsf{inU}}
\newcommand{\inUU}{\mathsf{inU{\sim}}}
\newcommand{\Set}{\textsf{Set}}
\newcommand{\mType}{\mathbf{Type}}
\newcommand{\Prop}{\textsf{Prop}}
\newcommand{\mProp}{\mathbf{Prop}}
\newcommand{\Setoid}{\textsf{Setoid}}
\newcommand{\Con}{\mathrm{Con}}
\newcommand{\Ty}{\mathrm{Ty}}
\newcommand{\Tm}{\mathrm{Tm}}
\newcommand{\Sub}{\mathrm{Sub}}
\newcommand{\Tms}{\mathrm{Tms}}
\newcommand{\id}{\mathrm{id}}
\newcommand{\op}{\mathrm{op}}
\newcommand{\cat}[1]{\underline{\mathbf{#1}}}
\newcommand{\U}{\textsf{U}}
\newcommand{\El}{\textsf{El}}
\newcommand{\Uty}{\mathds{U}}
\newcommand{\EL}{\mathds{E}l}

\newcommand{\Type}{\mathbf{Type}}
\renewcommand{\iff}{\leftrightarrow}
\newcommand{\Nat}{\mathbb{N}}
\newcommand{\Int}{\mathbb{Z}}
\newcommand{\Rat}{\mathbb{Q}}
\newcommand{\Real}{\mathbb{R}}
\newcommand{\Bool}{\mathrm{Bool}}

\newcommand{\reflu}{\textsf{refl}_\setoidU}
\newcommand{\symu}{\textsf{sym}_\setoidU}
\newcommand{\transu}{\textsf{trans}_\setoidU}
\newcommand{\reflel}{\textsf{refl}_\El}
\newcommand{\symel}{\textsf{sym}_\El}
\newcommand{\transel}{\textsf{trans}_\El}
\newcommand{\coeel}{\textsf{coe}_\El}
\newcommand{\cohel}{\textsf{coh}_\El}
\newcommand{\equ}[2]{#1 \sim_\setoidU #2}
\newcommand{\eqel}[3]{#1 \vdash #2 \sim_\El #3}

\newcommand{\List}{\mathrm{List}}
\newcommand{\rev}{\mathrm{rev}}

%\newtheorem{theorem}{Theorem}

\providecommand\mathbbm{\mathbb}
\def\lv{\mathopen{{[\kern-0.14em[}}}    % opening [[ value delimiter
\def\rv{\mathclose{{]\kern-0.14em]}}}   % closing ]] value delimiter
\newcommand{\eval}[1]{{\lv{#1}\rv}}

% TODO notes.
%\usepackage[textsize=small]{todonotes}
%\setlength{\marginparwidth}{2cm}
%\newcommand{\txatodo}[1]{\todo[fancyline,color=green!20]{#1}{}}

\title{Constructing a universe for the setoid model}
%\titlerunning{Constructing a universe for the setoid model}

\author{Thorsten Altenkirch}{School of Computer Science, University of Nottingham, UK}{psztxa@nottingham.ac.uk}{https://orcid.org/0000-0002-6582-5025}{Supported by USAF grant FA9550-16-1-0029.}
\author{Simon Boulier}{Inria, Nantes, France}{simon.boulier@inria.fr}{}{}
\author{Ambrus Kaposi}{E{\"o}tv{\"o}s Lor{\'a}nd University, Budapest, Hungary}{akaposi@inf.elte.hu}{https://orcid.org/0000-0001-9897-8936}{Supported by the National Research, Development and Innovation Fund of Hungary, financed under the Thematic Excellence Programme funding scheme, Project no. ED\_18-1-2019-0030 and the Bolyai Fellowship of the Hungarian Academy of Sciences, Project no.\ BO/00659/19/3.}
\author{Christian Sattler}{Chalmers University of Technology, Gothenburg, Sweden}{sattler@chalmers.se}{}{Supported by USAF grant FA9550-16-1-0029 and Swedish Research Council grant 2019-03765.}
\author{Filippo Sestini}{School of Computer Science, University of Nottingham, UK}{Filippo.Sestini@nottingham.ac.uk}{}{}

\authorrunning{T. Altenkirch and S. Boulier and A. Kaposi and C. Sattler and F. Sestini}

\Copyright{Thorsten Altenkirch and Simon Boulier and Ambrus Kaposi and Christian Sattler and Filippo Sestini} %TODO mandatory, please use full first names. LIPIcs license is "CC-BY";  http://creativecommons.org/licenses/by/3.0/

\ccsdesc[500]{Theory of computation~Logic~Type theory} %TODO mandatory: Please choose ACM 2012 classifications from https://dl.acm.org/ccs/ccs_flat.cfm 

\keywords{type theory, function extensionality, univalence, setoid model, induction-recursion, induction-induction} %TODO mandatory; please add comma-separated list of keywords

%\category{} %optional, e.g. invited paper

%\relatedversion{} %optional, e.g. full version hosted on arXiv, HAL, or other respository/website
%\relatedversion{A full version of the paper is available at \url{...}.}

%\supplement{}%optional, e.g. related research data, source code, ... hosted on a repository like zenodo, figshare, GitHub, ...

%\funding{(Optional) general funding statement \dots}%optional, to capture a funding statement, which applies to all authors. Please enter author specific funding statements as fifth argument of the \author macro.

%\acknowledgements{I want to thank \dots}%optional

%Editor-only macros:: begin (do not touch as author)%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\EventEditors{John Q. Open and Joan R. Access}
\EventNoEds{2}
\EventLongTitle{42nd Conference on Very Important Topics (CVIT 2016)}
\EventShortTitle{CVIT 2016}
\EventAcronym{CVIT}
\EventYear{2016}
\EventDate{December 24--27, 2016}
\EventLocation{Little Whinging, United Kingdom}
\EventLogo{}
\SeriesVolume{42}
\ArticleNo{23}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\maketitle

\begin{abstract}
The setoid model of type theory can be used to show the consistency of
intensional type theory with certain extensionality principles, like function
extensionality. In addition, Altenkirch's formulation of such model justifies a
universe of strict (definitionally-proof irrelevant) propositions supporting
propositional extensionality, a limited form of univalence according to which
logically equivalent propositions are equal. The appeal of this model
construction is that it takes place in a small, intensional, type theoretic
metatheory, therefore giving a method to boostrap extensionality.

Recently, Altenkirch's setoid model has been turned into a formal system, under
the name of Setoid Type Theory (SeTT). SeTT can be presented as an extension of
intensional Martin-Loef type theory with syntactic constructs that internalize
setoid reasoning. These give full access to the extensionality principles that
hold in the setoid model, while retaining the convenience of an intensional
theory.

As currently defined, SeTT is already a rich theory. However, its introspection
capabilities are currently lacking, since it only includes (univalent) universes
for propositions. We would like to extend SeTT with a universe of setoids
internalizing the notion of type beyond propositions. This amounts to extending
the setoid model with a semantics for such a universe.

In this paper, we present the construction of a (non-univalent) universe of
setoids within the setoid model. The universe is given in steps, first as an
inductive-recursive definition, which is then translated to an
inductive-inductive definition, and finally to an inductive family. Every step
is obtained from the previous by applying known reduction methods, although in a
novel way. Additionally, our construction shows the setoid model with the
additional encoding of the universe can still be defined in a relatively small
metatheory, that however must include a universe of strict propositions, indexed
W types, and a proof-irrelevant identity type with a strong transport rule. All
the mathematical developments described in the paper have been formalized in the
Agda proof-assistant.
\end{abstract}

\section{Introduction}

Intuitionistic type theory is a formal system designed by Per Martin-L\"of to be
a full-fledged foundation in which to develop constructive mathematics
\cite{mltt75, libretto}.
%
A central aspect of type theory is the coexistence of two notions of
equality. On the one hand definitional equality, the computational equality that
is built into the formalism. On the other hand ``propositional'' equality, the
internal notion of equality that is actually used to state and prove equational
theorems within the system. The precise balance between these two notions is at
the center of type theory research; however, it is generally understood that to
properly support formalization of mathematics, one should aim for a notion of
propositional equality that is as \emph{extensional} as possible.

Two extensionality principles seem particularly desirable, since they arguably
constitute the bare minimum for type theory to be comparable to set theory as a
foundational system for set-level mathematics, in terms of power and ergonomics.
One is function extensionality (or \emph{funext}), according to which functions
are equal if point-wise equal. Another is propositional extensionality
(or \emph{propext}), that equates all propositions that are logically equivalent.

Type theory with equality reflection, also known as \emph{extensional type
  theory} (ETT) does support extensional reasoning to some degree, but
unfortunately equality reflection makes the problem of type-checking ETT terms
computationally unfeasible: it is undecidable.

On the other hand, \emph{intensional type theory} (ITT) has nice computational
properties like decidable type checking that can make it more suitable for
computer implementation, but as usually defined (for example, in \cite{mltt75})
it severely lacks extensionality.
%
It is known from model constructions that extensional principles like funext are
consistent with ITT.
%
Moreover, ITT extended with the principle of \emph{uniqueness of identity
  proofs} (UIP) and funext is known to be as powerful as ETT
\cite{conservativity}. We could recover the expressive power of ETT by adding
these principles to ITT as axioms, however destroying some computational
properties like canonicity.

What we would like instead is a formulation of ITT that supports extensionality,
while retaining its convenient computational behaviour.
%
Unfortunately, canonicity for Martin-L{\"o}f's inductively defined
identity type says that if two terms are propositionally equal in the
empty context, then they are also definitionally equal. This rules out
function extensionality.
%
The first step towards a solution is to give up the idea of propositional
equality as a single inductive definition given generically for arbitrary
types. Instead, equality should be \emph{specific} to each type former in the
type theory, or in other words, every type former should be introduced alongside
an explanation of what counts as equality for its elements.
%% In this setting, function extensionality can simply be introduced as the
%% chosen notion of equality on function types.

This idea of pairing types together with their own equality relation goes back
to the notion of \emph{setoid} or \emph{Bishop set}. Setoids provide a quite
natural and useful semantic domain in which to interpret type theory. The first
setoid model was constructed to justify function extensionality without relying
on funext in the metatheory \cite{hofmann}. Moreover, it was shown by Altenkirch
\cite{setoid99} that if the model construction is carried out in a type
theoretic metatheory with a universe of strict (definitionally proof-irrelevant)
propositions, it is possible to define a univalent universe of propositions
satisfying propositional extensionality. The setoid model thus satisfies all the
extensionality principles that we would like to have in type theory. The
question is whether there exists a version of intensional type theory that
supports setoid reasoning, and hence the forms of extensionality enabled by it.

This question was revisited and answered in Altenkirch et al. \cite{mpc19}. In
this paper, the authors define Setoid Type Theory (SeTT), an extension of
intensional Martin-L\"of type theory with constructs for setoid reasoning, where
funext and propext hold by definition. SeTT is based on the \emph{strict} setoid
model of Altenkirch\footnote{a \emph{strict} model is one where every equation
  holds definitionally}, which makes it possible to show consistency via a
syntactic translation. This is in contrast with other type theories based on the
setoid model, like Observational Type Theory \cite{alti:ott-conf, alti:ott-conf}
and XTT \cite{xtt}, which instead rely on ETT for their justification. A major
property of SeTT is thus to illustrate how to bootstrap extensionality, by
translation into a small intensional core.

SeTT as defined in \cite{mpc19} is already a rich theory, but its introspection
capabilities are currently lacking, as its universes are limited to
propositions. We would like to internalise the notion of type in SeTT, thus
extending the theory with a universe of setoids.
%
This goal brings up several questions, one of which has to do with the notion of
equality with which the universe should come equipped: the universe of setoids
is itself a setoid (as any type is) so it certainly cannot be univalent, since
setoids lack the necessary structure.
%
Another issue is the way such universe can be justified by the setoid model, and
in particular what principles are needed in the metatheory to do so.

\paragraph*{Contributions}

This paper documents our work towards the construction of a universe of setoids
inside the setoid model, and tries to answer these and other questions related
to the design and implementation of this construction. Our main contribution is
the construction of the universe in the model; this is given in steps, first as
an inductive-recursive definition, which is then translated to an
inductive-inductive definition, and subsequently to an inductive type. As a
consequence, we show that we only need to assume indexed W-types and
proof-irrelevant identity types in the metatheory (along with some obligatory
basic tools like $\Sigma$ and $\Pi$ types) to construct the universe.

The universe constructions presented in this paper are, to our knowledge, the
first examples of two kinds of data type reductions in an intensional
metatheory: the first involving an inductive-recursive type which includes
strict propositions, and the second involving an infinitary inductive-inductive
type.

Finally, the mathematical contents of this paper have been formalized in the
proof-assistant Agda (see \cite{agda-code}).

\paragraph*{Structure of the paper}

We begin by describing the metatheory that we will use throughout the paper, in
Section~\ref{sec:metatheory}. In Section~\ref{sec:setoid-model}, after briefly
recalling \emph{categories with families} as an abstract notion of models of
type theory, we outline Altenkirch's setoid model as given in \cite{mpc19}. We
then briefly discuss the rules of Setoid Type Theory in Section~\ref{sett}.

In Section~\ref{setoid-universe} we discuss the setoid model and various design
choices related to it. We then recall inductive-recursive universes, and the way
they can be equivalently defined as a plain inductive definition, in
Section~\ref{ir-universes}.
%
We then provide, in Section~\ref{ir-setoid-universe}, a first complete
definition of the setoid universe using a special form of induction-recursion.
This form of induction-recursion is not known to be reducible to plain inductive types.
Then we describe an alternative definition of the universe in
Section~\ref{ii-universe}, that does not rely on induction-recursion but instead
on infinitary induction-induction. This inductive-inductive encoding of the
universe is obtained from the inductive-recursive one, inspired by the method of
Section~\ref{ir-universes}.
%
We end the series of universe constructions with
Section~\ref{inductive-universe}, where we outline a purely inductive definition
of the setoid universe, obtained from the inductive-inductive one.

We conclude the paper with a discussion of further work in
Section~\ref{further-work}.

\subsection{Related work}

The setoid model was first described in \cite{hofmann} in order to add
extensionality principles to Type Theory such as function extensionality and
propositional extensionality. A strict variant of the setoid model was given in
\cite{setoid99} using a definitionally proof-irrelevant universe of
propositions. Recently, support for such a universe was added to the
proof-assistants Agda and Coq \cite{agda-prop}, allowing a full formalization of
Altenkirch's setoid model. Setoid Type Theory (SeTT) is a recently developed
formal system derived from this model construction \cite{mpc19}. Observational
Type Theory (OTT) \cite{alti:ott-conf, alti:ott-conf} is a syntax for the setoid
model differing from SeTT for the use of a different notion of heterogeneous
equality. Moreover, the consistency proof for OTT relies on Extensional Type
Theory, whereas for SeTT it is obtained via a syntactic translation.
%
XTT \cite{xtt} is a cubical variant of OTT where the equality type is defined
using an interval pretype. XTT's universes support universe induction, whereas
it is left open whether the construction presented here supports this principle.

The principle of propositional extensionality in the setoid model is an instance
of Voevodsky's univalence axiom \cite{hottbook}. The cubical set model is a
constructive model justifying this axiom \cite{cubical-sets}. A type theory
extracted from this model is Cubical Type Theory \cite{cubical}. The
relationship between the cubical set model and cubical type theory is similar to
that between the setoid model and SeTT.
%
Compared to cubical type theories, SeTT has the advantage that the equality type
satisfies more definitional equalities. For instance, whereas in cubical type
theory equality of functions is isomorphic to pair-wise equality, in SeTT the
isomorphism is replaced by a definitional equality. SeTT is also a syntactically
straightforward extension of Martin-L\"of Type Theory, that does not require
exotic objects like the internal pretype. In turn, the obvious advantage of
cubical type theory is that it is not limited to setoids.

An exceptional aspect of the metatheory used in this paper is the presence of a
proof-irrelevant identity type with a strong transport rule allowing to
eliminate into arbitrary types.
%
In \cite{abel:nbe09}, Abel gives a proof of normalization for the
Logical Framework extended with a similar proof-irrelevant equality type.
%
Abel and Coquand show in \cite{abel2019failure} that the combination of
impredicativity with a strong transport rule results in terms that fail to
normalize.

\section{$\mlttp$}\label{sec:metatheory}

This section describes $\mlttp$, our ambient metatheory. We employ Agda notation
to write down $\mlttp$ terms throughout the paper.

One of the main appeals of Altenkirch's setoid model is that it can justify
several useful extensionality principles while being defined in a small
intensional metatheory.
%
We tried to stay true to this idea when figuring out the necessary
metatheoretical tools for the universe construction in this paper. In
particular, we wanted to avoid having to assume strong definition schemas that
go beyond inductive families.

$\mlttp$ is thus an intensional type theory in the style of Martin-L\"of type
theory with $\Pi, \Sigma, \textsf{Bool}, \mathbf{0}, \mathbf{1}$, and a universe
of strict propositions $\mProp$. $\Sigma$ types are defined negatively by
pairing $\_,\_$ and projections $\pi_1, \pi_2$. We also have definitional $\eta$
rules for $\Pi, \Sigma$, and $\mathbf{1}$ types. Propositions can be lifted to
types via a lifting $\textsf{Lift} : \mProp \to \mType$, with constructor
$\textsf{lift} : \{P : \mProp \} \to P \to \textsf{Lift}\ P$ and destructor
$\textsf{unlift} : \{P : \mProp \} \to \textsf{Lift}\ P \to P$.

We also require indexed W-types, both in $\mType$ and $\mProp$; hence we have $W
: (S : \mType) \to (S \to \mType) \to \mType$ and $W_p : (S : \mType) \to (S \to
\mType) \to \mProp$. The elimination principle of $W_p$ only allows defining functions into $\mProp$s.
%
From $W_p$ we can define propositional truncation $\|\_\| : \mType \to \mProp$, with constructor
  $|\_| : \{A : \mType \} \to A \to \| A \|$ and eliminator
  $\textsf{elim}_{\|\_\|} : \{P : \mProp \} \to (A \to P) \to \| A \| \to P$.

In addition to type formers in $\mType$, we will need the propositional versions
of $\mathbf{0}$, $\mathbf{1}$, $\Pi$, and $\Sigma$. The latter three can be defined from their
$\mType$ counterparts via truncation. That is, given $P : \mProp$ and $Q : P \to
\mProp$:
%
\begin{align*}
  \mathbf{1}_p & :\equiv \| \mathbf{1} \| \\
  \Pi_p\ P\ Q & :\equiv \| \Pi\ (\textsf{Lift} \ P)\ (\textsf{Lift} \circ Q \circ \textsf{unlift}) \| \\
  \Sigma_p\ P\ Q & :\equiv \| \Sigma\ (\textsf{Lift} \ P)\ (\textsf{Lift} \circ Q \circ \textsf{unlift}) \|
\end{align*}
We assume that we have
$\mathbf{0}_p:\mProp$ together with $\mathsf{exfalso}_p :\{A:\mType \} \to \mathbf{0}_p \to A$.

Finally, we will assume an identity type in the style of Martin-L\"of's
inductive identity type. The main difference is that our identity type is a
$\mProp$-valued relation. We also include a transport combinator
\textsf{transp}.
%
\begin{align*}
  & \textsf{Id} : \{A : \mType \} \to A \to A \to \mProp \\
  & \textsf{refl} : \{A : \mType \} (a : A) \to \textsf{Id}\ a\ a \\
  & \textsf{transp} : \{A : \mType \} (C : A \to \mType) \{a_0\ a_1 : A\} \to \textsf{Id}\ a_0\ a_1 \to C\ a_0 \to C\ a_1
\end{align*}

The \textsf{transp} combinator provides a strong elimination principle allowing
to eliminate a strict proposition (the identity type) into arbitrary types.
%
The reason to have an identity type in $\mProp$ with such a strong transport
rule are made clear in Section~\ref{inductive-universe}.
%
Note that this identity type must necessarily be assumed as primitive; in fact,
even though we could have defined \textsf{Id} from $W_p$, \textsf{transp} is not
definable from $W_p$ elimination.

\subsection{Formalization}

A universe of strict propositions has been recently added to the Agda proof
assistant \cite{agda-prop}, making \emph{most} of $\mlttp$ a subset of Agda,
with the exception of the proof-irrelevant identity type. Most of the universe
constructions presented here have been formalized and proof-checked using Agda,
with the proof-irrelevant identity type and the strong transport rule added via
postulates and rewriting. The formalization can be found in \cite{agda-code}.

For convenience, we slightly deviate from $\mlttp$ both in the paper and in the
formalization, for instance by relying on pattern matching instead of
eliminators, and using primitive versions of $\mProp$-valued $\Pi$ and $\Sigma$
types instead of deriving them from truncation. We operate under the assumption
that everything can be equivalently carried out in $\mlttp$, although we haven't
fully checked all the necessary details.

\section{Setoid model}\label{sec:setoid-model}

By \emph{setoid model} we mean a class of models of type theory where
contexts/closed types are interpreted as setoids, i.e. sets with an equivalence
relation, and dependent types are interpreted as dependent/indexed setoids.
%
A setoid model was first given for intensional type theory by M.\ Hofmann
\cite{hofmann}, in order to provide a semantics for extensionality principles such
as function and propositional extensionality.

Here we consider a similar model construction due to Altenkirch
\cite{setoid99}. The peculiarity of this model is that it is presented in a type
theoretic and intensional metatheory which includes a strict universe of
propositions.

The setoid model thus defined validates function extensionality, a universe of
propositions with propositional extensionality, and quotient types. Therefore,
it provides a way to bootstrap and ``explain'' extensionality, since the model
construction effectively gives an implementation of various extensionality
principles in terms of a small, completely intensional theory.

\subsection{Setoid model as a CwF}

The setoid model can be framed categorically as a category with families (CwF,
\cite{internal-tt}) with extra structure for the various type and term
formers. The core structure of a CwF can be given as the following signature:
\begin{align*}
  \Con &: \mType \\
  \Ty &: (\GG : \Con) \to \mType \\
  \Sub &: (\GG\ \GD : \Con) \to \mType \\
  \Tm &: (\GG : \Con) \to \Ty\ \GG \to \mType
\end{align*}

In our presentation of the setoid model, contexts are given by setoids, that is,
types together with an equivalence relation. A key point of the model is that the
equivalence relation is valued in $\mProp$ and is thus definitionally proof
irrelevant.
\[
\infer{
  \begin{aligned}
    & | \GG | : \mType \\
    & \GG^\sim : | \GG | \to | \GG | \to \mProp \\
    & \textsf{refl}\ \GG : (\gamma : | \GG |) \to \GG^\sim\,\gamma\,\gamma \\
    & \textsf{sym} \ \GG : \forall\{\gamma_0\ \gamma_1\} \to \GG^\sim\,\gamma_0\,\gamma_1
    \to \GG^\sim\,\gamma_1\,\gamma_0 \\
    & \textsf{trans} \ \GG : \forall\{\gamma_0\ \gamma_1\ \gamma_2\}
    \to \GG^\sim\,\gamma_0\,\gamma_1
    \to \GG^\sim\,\gamma_1\,\gamma_2
    \to \GG^\sim\,\gamma_0\,\gamma_2
  \end{aligned}
}{
  \GG : \Con
}
\]

Types in a context $\GG$ are given by displayed setoids over $\GG$
with a fibration condition given by $\textsf{coe}$, $\textsf{coh}$. In
the following, we somtimes omit implicit quantifications such as the $\forall\{\gamma_0\ \gamma_1\}$ in the type of $\textsf{sym}\,\GG$.
\[
\infer{
  \begin{aligned}
    & | A | : | \GG | \to \mType \\
    & A^\sim : \{\gamma_0\ \gamma_1 : | \GG |\}
    \to \GG^\sim\ \gamma_0\ \gamma_1 \to | A | \gamma_0 \to | A | \gamma_1 \to \mProp \\
    & \textsf{refl*} : \{\gamma : | \GG | \} (a : | A | \gamma) \to A^\sim\ (\textsf{refl}\ \GG\ \gamma)\ a\ a \\
    & \textsf{sym*} : \forall\{\gamma_0\,\gamma_1\,a_0\,a_1\}\{p : \GG^\sim\ \gamma_0\ \gamma_1\}
    \to A^\sim\ p\ a_0\ a_1 \to A^\sim\ (\textsf{sym}\ \GG\ p)\ a_1\ a_0 \\
    & \textsf{trans*} : A^\sim\ p_0\ a_0\ a_1\to A^\sim\ p_1\ a_1\ a_2\to A^\sim\ (\textsf{trans}\,\GG\,p_0\,p_1)\ a_0\ a_2\\
    & \textsf{coe} : \GG^\sim\ \gamma_0\ \gamma_1 \to | A | \gamma_0 \to | A | \gamma_1 \\
    & \textsf{coh} : (p : \GG^\sim\ \gamma_0\ \gamma_1) (a : | A | \gamma_0)
    \to A^\sim\,p\,a\,(\textsf{coe}\,A\,p\,a) \\
  \end{aligned}
}{
  A : \Ty\ \GG
}
\]

This definition of types in the setoid model is different from the one in
\cite{setoid99}, but it is equivalent to it \cite[Section 1.6.1]{simonthesis}. The main
difference here is in the use of a heterogeneous equivalence relation $A^\sim$
in the definition of types.

Substitutions are interpreted as functors between the corresponding setoids,
whereas terms of type $A$ in context $\GG$ are sections of the type seen as a
setoid fibration $\GG . A \to \GG$. Note that we only need to include components
for the functorial action on objects and morphisms, since the functor laws
follow from proof-irrelevance in the metatheory, and thus hold definitionally.
\\
\begin{minipage}{0.5\textwidth}
\[
\infer{
  \begin{aligned}
    & | \sigma | : | \GG | \to | \GD | \\
    & \sigma^\sim : \GG^\sim\, \rho_0\, \rho_1 \to \GD^\sim\, (|\sigma|\rho_0)\, (|\sigma|\rho_1)
  \end{aligned}
}{
  \sigma : \Sub\ \GG\ \GD
}
\]
\end{minipage}
\begin{minipage}{0.5\textwidth}
\[
\infer{
  \begin{aligned}
    & | t | : (\gamma : | \GG |) \to | A | \, \gamma \\
    & t^\sim : (p : \GG^\sim\ \gamma_0\ \gamma_1) \to A^\sim\ p\ (|t|\gamma_0)\ (|t|\gamma_1)
  \end{aligned}
}{
  t : \Tm\ \GG\ A
}
\]
\end{minipage}
\\

We can show that the setoid model validates the usual basic type formers ($\Pi,
\Sigma$, etc.), function extensionality and a universe of strict
propositions ith propositional extensionality \cite{setoid99}. Note that
we don't need identity types or inductive types (W-types) for this.

\subsection{Setoid Type Theory}\label{sett}

The setoid model presented in the previous section is \emph{strict}, that is,
every equation of a CwF holds by definition in the semantics. One advantage of
strict models is that they can be turned into \emph{syntactic translations}, in
which syntactic objects of the source theory are interpreted as their
counterparts in another \emph{target} theory. In the case of the setoid model,
this gives rise to a \emph{setoid translation}, where source contexts are
interpreted as target contexts together with a target type representing the
equivalence relation, and so on.\footnote{%
Semantically, this translation corresponds to a model construction, in
particular a functor from the category of models of the target theory to the
category of models of what will be Setoid Type Theory.  Since the setoid
translation is structural in the context component, we can work with models in
the style of categories with families rather than contextual categories.
}

A setoid translation is used in \cite{mpc19} to justify Setoid Type Theory
(SeTT), an extension of Martin-L\"of type theory (+ $\mProp$) with equality
types for contexts and dependent types that reflect the setoid equality of the
model.

We recall the rules of SeTT that extend regular MLTT below, but with a
variation: whereas the equality types in \cite{mpc19} are stated as elements of
SeTT's internal universe of propositions, here we state the context equalities
as elements of the external, metatheoretic universe $\mProp$. This makes it easier
to define models of SeTT as contexts do not need to be partially fibrant. Equality on
types is defined as before in \cite{mpc19}.

We have a universe of propositions $\Prop$ defined as follows:
\[
\infer{
  \Prop : \Ty\ \GG
}{
  \GG : \Con
}
\qquad
\infer{
  \underline{P} : \Ty\ \GG
}{
  P : \Tm\ \GG\ \Prop
}
\qquad
\infer{
  u \equiv v\vphantom{\Prop}
}{
  u : \Tm\ \GG\ \underline{P} && v : \Tm\ \GG\ \underline{P}
}
\]

Equality type constructors for contexts and dependent types internalize the idea
that every context and type comes equipped with a setoid equivalence
relation. Note that $\mProp$ is the universe of the metatheory while $\Prop$ is
the internal one. As in the model, equality for dependent types is indexed over context
equality.
\[
\infer{
  \GG^\sim\ \rho_0\ \rho_1 : \mProp
}{
  \GG : \Con \qquad \subj{\rho_0, \rho_1}{\DD}{\GG}
}
\qquad
\infer{
  A^{\sim}\ \rho_{01}\ a_0\ a_1 : \Tm\ \DD\ \Prop
}{
  \deduce{
    a_0 : \Tm\ \DD\ A[\rho_0] \qquad a_1 : \Tm\ \DD\ A[\rho_1]
  }{
    A : \Ty\ \GG \qquad \rho_{01} : \GG^{\sim}\ \rho_0\ \rho_1
  }
}
\]

We have rules witnessing that these are indeed equivalence relations. We only
recall reflexivity:
\[
\infer{
  \textsf{R}\ \rho : \GG^\sim\ \rho\ \rho
}{
  \rho : \Sub\ \GD\ \GG
}
\qquad
\infer{
  \textsf{R}\ a : \Tm\ \GG\ \underline{A^\sim\ (\textsf{R}\ \rho)\ a\ a}
}{
  A : \Ty\ \GG
  \qquad
  \rho : \Sub\ \GD\ \GG
  \qquad
  a : \Tm\ \GD\ A[\rho]
}
\]

In addition, we also have rules representing the fact that every construction in
SeTT respects setoid equality, so that we can transport along any such equality:
    \[
    \infer{
      \deduce{
        \tmj{\GD}{\coh_A\ p\ a}{\underline{A^\sim\ p\ a\ (\coe_A\ p\ a)}}
      }{
        \tmj{\GD}{\coe_A\ p\ a}{A[\rho_1]}
      }
    }{
      \tyj{\GG}{A} \qquad \subj{\rho_0, \rho_1}{\GD}{\GG} \qquad
      p : \GG^\sim\ \rho_0\ \rho_1\qquad
      \tmj{\GD}{a}{A[\rho_0]}
    }
    \]

Notably, equality types in SeTT compute definitionally on concrete type
formers. In particular, they compute to their obvious intended meaning, so that
an equality of pairs is a pair of equalities, an equality of functions is a map
of equalities, and so on. From this, we get definitional versions of function
and propositional extensionality.
%% %
%% \begin{align*}
%%   & (\Pi(a : A)\ B)^\sim\ p\ f_0\ f_1 = \Pi(a_0\,a_1 : A)... \\
%%   & (\Sigma\ A\ B)^\sim\ p\ (a_0, b_0)\ (a_1, b_1) = ... \\
%%   & \Prop^\sim\ p\ P\ Q = ...
%% \end{align*}

We can easily recover the usual Martin-L\"of identity type from setoid equality,
with transport implemented via coercion.
\[
\infer{
  \textsf{Id}_A\ a_0\ a_1 :\equiv A^{\sim}\ (\R\ \GG)\ a_0\ a_1 : \Tm\ \GG\ \Prop
}{
  \tyj{\GG}{A} \qquad \tmj{\GG}{a_0, a_1}{A}
}
\]
\[
\infer{
  \textsf{transp}\ P\ p\ t :\equiv
    \coe\ P\ (\textsf{R}\ \textsf{id} , p)\ t : \Tm\ \GG\ P[a_1]
}{
  P : \Ty\ (\GG . A)
  \qquad
  p : \Tm\ \GG\ (\Id\ A\ a_0\ a_1)
  \qquad
  t : \Tm\ \GG\ P[a_0]
}
\]

We can also derive Martin-L\"of's J eliminator for this homogeneous identity
type. The only caveat is that $\textsf{transp}$ and the J eliminator do not
compute definitionally on reflexivity.

\section{Universe of setoids}\label{setoid-universe}

As pointed out in the introduction, SeTT is seriously limited by the lack of a
universes internalizing the notion of setoid. Our goal is to extend SeTT with a
universe of setoids; since SeTT is a direct syntactic reflection of the setoid
model, this essentially amounts to showing that a universe of setoids with the
necessary structure and equations can be constructed within the setoid
model. This opens several questions and possible design choices.

A first fundamental consideration has to do with the very definition of the setoid
universe: as any type in the setoid model, this universe must be a setoid and
thus come equipped with an equivalence relation. However, unlike the universe of
propositions, a universe of setoids cannot be univalent, since this would force
it to be a groupoid. The obvious choice is therefore to have a non-univalent
universe, and instead define the universe's relation so that it reflects a
simple syntactic equality of codes rather than setoid equivalence.

Another question has to do with the metatheoretic tools required to carry out
the construction of the universe. In fact, one of the main aspects of the setoid
model construction recalled in Section~\ref{sec:setoid-model} and shown originally
in \cite{setoid99} is that it can be carried out in a very small type theoretic
metatheory, thus providing a way to reduce extensionality to a small intensional
core.
%
We would like to stay faithful to this ideal when constructing this setoid
universe.

A known and established method for defining universes in type theory relies on
induction-recursion (IR), a definition schema developed by Dybjer
\cite{ir-dybjer, dybjer-setzer}. Inductive-recursive definitions can be found
throughout the literature, from the already mentioned type theoretic universes,
including the original formulation \`{a} la Tarski by Martin-L\"of
\cite{libretto}, to metamathematical tools like computability predicates.

Although universe constructions in type theory---including our own setoid
universe---are naturally presented as inductive-recursive definitions, they may
not necessarily require a metatheory with induction-recursion. In fact, it is
possible to reduce some instances of induction-recursion to plain induction
(more specifically, inductive families), including some universe definitions. We
recall this reduction in Section~\ref{ir-universes}.

Other design choices on the setoid universe are less essential, but still
require careful consideration. For instance, one question is whether the setoid
universe should support universe induction, thus exposing the inductive
structure of the codes. Such elimination principle is known to be inconsistent
with univalence, although this is not an issue in our case; nevertheless it's
not immediately clear if the elimination principle can be justified by the
semantics, that is, if our encoding of the setoid universe in the model allows
to define such a universe eliminator.
%
The question arises because our final encoding of the setoid universe only
supports a weak form of elimination, for reasons that are explained in
Section~\ref{inductive-universe}. Although not currently needed, a stronger
eliminator might be necessary to justify universe induction. This problem should
not arise in the other encodings of the setoid universe (as given in
Section~\ref{ir-setoid-universe} and Section~\ref{ii-universe}).

Another design choice has to do with how the setoid universe relates to the
other universes. One could provide a code for $\Prop$ in the setoid universe.
Moreover, the setoid universes could form a hierarchy, possibly
cumulative.

Yet another choice is whether to have two separate sorts, one for propositions
and one for sets (with propositions convertible to sets) or a single sort of
types (sets), with propositions given by elements of a universe of proposition,
which is a (large) type. We have chosen to present the second option to fit with
the standard notion of (unisorted) CwF. However, this has downsides: to even
talk about propositions, we need to have a notion of large types. The first
option is more symmetric: we can have parallel hierarchies for propositions and
sets.

\subsection{Inductive-recursive universes}\label{ir-universes}

An inductive-recursive universe is given by a type of codes $\U : \mType$, and a
family $\El : \U \to \mType$ that assigns, to each code corresponding to some
type, the meta-theoretic type of its elements. The resulting definition is
inductive-recursive because the inductive type of codes is defined
simultaneously with the recursive function $\El$.

As an example, consider the following definition of a small universe with
bool and $\Pi$.

\begin{minipage}{0.45\textwidth}
\begin{align*}
  & \textsf{data}\ \U\ : \mType \\
  & \quad \textsf{bool} : \U \\
  & \quad \textsf{pi} : (A : \U) \to (\El\ A \to \U) \to \U \\
\end{align*}
\end{minipage}
\begin{minipage}{0.45\textwidth}
\begin{align*}
  & \El\ : \U \to \mType \\
  & \El\ \textsf{bool} :\equiv \mathbbm{2} \\
  & \El\ (\textsf{pi}\ A\ B) :\equiv (a : \El\ A) \to \El\ (B\ a) \\
\end{align*}
\end{minipage}

Induction-recursion is arguably a nice and natural way to define internal
universes in type theory, however it is not always strictly required.
%
We can translate basic instances of induction-recursion into inductive families
using the equivalence of $I$-indexed families of types and types over $I$
(that is, $\mType_i \to I$) \cite{malatasta13smallir}.

In our case, we can encode $\U$ as an inductive type $\inU$ that
\emph{carves out} all types in $\mType$ that are in the image of $\El$. In other
words, $\inU$ is a predicate that holds for any type that would have been
obtained via $\El$ in the inductive-recursive definition. As $\El$ is indexed by
the type of codes, the definition of $\inU$ quite expectedly reflects the
inductive structure of codes.
%
\begin{alignat*}{10}
  & \textsf{data}\ \inU && : \mType \to \mType_1 \\
  & \quad \textsf{inBool} && : \textsf{in-U}\ \mathbbm{2} \\
  & \quad \textsf{inPi} && :  \inU\ A \to ((a : A) \to \inU\ (B\ a)) \to \inU\ ((a : A) \to (B\ a))
\end{alignat*}

$\U$ and $\El$ can be given by $\U :\equiv \Sigma\ (A : \mType)\ (\textsf{in-U}\ A)$ and $\El :\equiv \pi_1$.

Note that this construction gives rise to a universe in $\mType_1$, rather than
$\mType$, since the definition of $\U$ quantifies over all possible types in
$\mType$. Hence this kind of construction requires a metatheory with at least
one universe.

\subsection{Inductive-recursive setoid universe}\label{ir-setoid-universe}

In this section we give a first definition of the setoid universe, as a direct
generalization of the simple inductive-recursive definition just shown. We only
consider a very small universe with bool type $\mathbbm{2}$ and $\Pi$ for
simplicity; a more realistic universe that includes more type formers
can be found in the Agda formalization.

To construct the universe of setoids in the setoid model, we first of all need
to define a type $\Uty : \Ty\ \GG$ for every $\GG : \Con$, and for every $A :
\Tm\ \GG\ \Uty$ a type $\mathds{E}l\ A : \Ty\ \GG$. Recalling
Section~\ref{sec:setoid-model}, these are essentially record types made of several
components. Since $\Uty$ is a closed type, it requires the same data of a
setoid; in particular, we need a type of codes together with an equivalence
relation reflecting equality of codes, in addition to proofs that these are
indeed equivalence relations: \\
%
\begin{minipage}{0.5\textwidth}
\begin{align*}
  & \textsf{data} \ \setoidU : \mType_1 \\
  & \_\sim_\setoidU\_ : \setoidU \to \setoidU \to \mProp_1
\end{align*}
\end{minipage}
\begin{minipage}{0.5\textwidth}
\begin{align*}
  & \textsf{refl}_\setoidU : (A : \setoidU) \to \equ{A}{A} \\
  & \textsf{sym}_\setoidU : \equ{A}{B} \to \equ{B}{A} \\
  & \textsf{trans}_\setoidU : \equ{A}{B} \to \equ{B}{C} \to \equ{A}{C}
\end{align*}
\end{minipage}
\\

$\EL$ is given by a family of setoids indexed over the universe, that is, a way
to assign to each code in the universe a carrier set and an equivalence
relation.
%
\begin{align*}
  & \El : \setoidU \to \mType \\
  & \_\vdash\_\sim_\El\_ : \{a\ a' : \setoidU\} \to a \sim_\setoidU a' \to \El\ a \to \El\ a' \to \mProp
\end{align*}

Note that $\eqel{\_}{\_}{\_}$ is indexed over equality on the universe, because
$\El$ is a displayed setoid over $\setoidU$, hence in particular it must respect the setoid
equality of $\setoidU$.
%
We also require data and proofs that make sure we get setoids out of $\El$:
\begin{align*}
  & \textsf{refl}_\El : (A : \setoidU) (x : \El\ A) \to \eqel{\reflu\ A}{x}{x} \\
  & \textsf{sym}_\El : \eqel{p}{x}{x'} \to \eqel{\symu\ p}{x'}{x} \\
  & \textsf{trans}_\El : \eqel{p}{x}{x'} \to \eqel{q}{x'}{x''} \to \eqel{\transu\ p\ q}{x}{x''} \\
  & \coeel : \equ{A}{B} \to \El\ A \to \El\ B \\
  & \cohel : (p : \equ{A}{A'}) \ (x : \El\ A) \to \eqel{p}{x}{\coeel\ p\ x}
\end{align*}
%
We give an inductive definition of $\setoidU$, mutually with a recursive definition
of the 4 functions
$\_\sim_\setoidU\_$, $\textsf{refl}_\setoidU$, $\El$ and $\_\vdash\_\sim_\El\_$.
The other functions are then recursively defined:
\begin{itemize}
\item $\textsf{refl}_\El$ alone,
\item $\textsf{sym}_\setoidU$ and $\textsf{sym}_\El$ mutually,
\item $\textsf{trans}_\setoidU$, $\textsf{trans}_\El$, $\coeel$ and $\cohel$ mutually.
\end{itemize}
The whole construction is quite long, below we only show the more interesting
definitions of $\setoidU$ and $\El$: \\
\begin{minipage}{0.5\textwidth}
\begin{align*}
  & \textsf{data}\ \setoidU : \mType_1 \\
  & \quad \textsf{bool} : \setoidU \\
  & \quad \textsf{pi}
  :  (A : \setoidU) (B : \El\ A \to \setoidU)\\
  & \ \qquad \to (\{x\ x' : \El\ A\} \to \textsf{refl}_\setoidU\ A \vdash x \sim_\El x'\\
  & \qquad\quad \to B\ x \sim_\setoidU B\ x')
  \to \setoidU
\end{align*}
\end{minipage}
\begin{minipage}{0.5\textwidth}
\begin{align*}
  & \El\ \textsf{bool} :\equiv \mathbbm{2} \\
  & \El\ (\textsf{pi}\ A\ B\ h) :\equiv \\
  & \qquad \Sigma\ (f : (a : \El\ A) \to \El\ (B\ a)) \\
  & \qquad \quad
  (\forall\{x\ x'\}(p : \eqel{\reflu\ A}{x}{x'}) \\
  & \qquad \quad\to \eqel{h\ p}{f\ x}{f\ x'})
\end{align*}
\end{minipage}
\\

Note that in the definition of $\setoidU$ we require that the family $B : \El\ A
\to \setoidU$ be a setoid morphism, respecting the setoid equalities involved.
%
This choice is crucial for the definition of $\El$ to go through, in particular
since we eliminate the code for $\Pi$ types into the setoid of functions that
map equal elements to equal results. To state this mapping property we need to
compare elements in different types, coming from applying $f$ to different
arguments $x$ and $x'$. We know that $x$ and $x'$ are equal, but to conclude
$\equ{B\ x}{B\ x'}$ we need to know that $B$ respects setoid equality. This is
exactly what we get from our definition of $\setoidU$.

We can now give a full definition of the setoid universe, and of $\EL\ A$ for
any $A : \Tm\ \GG\ \Uty$: \\
%
\begin{minipage}{0.5\textwidth}
\begin{align*}
  & | \Uty | :\equiv \lambda\, \gamma . \, \setoidU \\
  & \Uty^\sim :\equiv \lambda \,p\, x\, y . \,x \sim_{\setoidU} y \\
  & \textsf{refl}\ \Uty :\equiv \reflu \\
  & ... \\
  & \textsf{coe}\ \Uty :\equiv \lambda\,p\,a . \, a \\
  & \textsf{coh}\ \Uty :\equiv \lambda\,p . \, \reflu
\end{align*}
\end{minipage}
\begin{minipage}{0.5\textwidth}
\begin{align*}
  & | \EL\ A | :\equiv \lambda \, \gamma . \, \El\ (| A | \,\gamma) \\
  & (\EL\ A)^\sim :\equiv \lambda \, p \, x \, y . \, \eqel{A^\sim\,p}{x}{y} \\
  & \textsf{refl}\ (\EL\ A) :\equiv \reflel \\
  & ... \\
  & \textsf{coe}\ (\EL\ A) :\equiv \lambda\,p.\, \textsf{coe}_{\El}\,(A^\sim\,p) \\
  & \textsf{coh}\ (\EL\ A) :\equiv \lambda\,p.\, \textsf{coh}_{\El}\,(A^\sim\,p)
\end{align*}
\end{minipage}
\\

We can show that $\Uty$ is closed under $\Pi$ types and booleans such
that $\EL\,(\mathsf{pi}\,A\,B) \equiv \Pi\,(\EL\,A)\,(\EL\,B)$ and
$\EL\,\mathsf{bool} = \mathsf{Bool}$. The universe can be closed under
more constructions if more codes are added to $\setoidU$.

This gives a complete definition of a universe of setoids, which is, however,
inductive-recursive. Moreover, the kind of recursion involved in this definition
is particularly complex, and not obviously reducible to well-understood notions
of induction-recursion like the one described in \cite{dybjer-setzer}. In any
case, we would like to avoid extending the metatheory with any form of
induction-recursion in order to keep the metatheory as small and
essential as possible.

In the next section we transform our current inductive-recursive definition to
one that doesn't use induction-recursion.
%
The way this is done is inspired by the well-known trick to eliminate
induction-recursion described in Section~\ref{ir-universes}, but modified in a
novel way to account for the presence of $\mProp$-valued types. To our
knowledge, this is the first time this reduction method is applied to an
inductive-recursive type of this kind.

\subsection{Inductive-inductive setoid universe}\label{ii-universe}

We will follow the method outlined in Section~\ref{ir-universes}. In
addition to $\inU$ for defining $\U$, we also introduce a family
$\inUU$ of binary relations between types in the universe, from which we
then define $\_\sim_{\setoidU}\_$.
%
\begin{align*}
  & \textsf{data}\ \inU : \mType \to \mType_1 \\
  & \textsf{data}\ \inUU : \{A\ A' : \mType\} \to \inU\ A \to \inU\ A' \to (A \to A' \to \mProp) \to \mType_1
\end{align*}

Note that $\inU$ appears in the sort of $\inUU$. Since these types are
mutually defined, they form an instance of \emph{induction-induction}, a schema
that allows the definition of a type mutually with other types that contain the
first one in their signature \cite{ii}.\footnote{The main example of
  induction-induction is the intrinsic definition of a dependent type theory in
  type theory \cite{tt-in-tt}.}

As in the universe example in Section~\ref{ir-universes}, we now define
$\setoidU$ as a $\Sigma$ type, and $\El$ as the corresponding first projection.
\begin{alignat*}{10}
  & \setoidU && : \mType_1 && \El : \setoidU \to \mType \\
  & \setoidU && :\equiv \Sigma\ (X : \mType)\ (\inU\ X) \hspace{5em} && \El :\equiv \pi_1
\end{alignat*}

What is left now is to define the setoid equality relation on the universe, as
well as the setoid equality relation on $\El\ A$ for any $A$ in $\setoidU$.
%
Two codes $A, B$ in the universe $\setoidU$ are equal when there exists a setoid
equivalence relation on their respective sets $\El\ A$ and $\El\ B$. Intuitively,
since elements of a setoid are only ever compared to elements of the same
setoid, this should only be possible if $A$ and $B$ are codes for the same setoid,
that is, if $A \sim_{\setoidU} B$. Existence and well-formedness of such
relations is expressed via the type $\inUU$ just defined, hence we would
expect $A \sim_{\setoidU} B$ to be defined as follows:
\[
(A, p_A) \sim_{\setoidU} (B, p_B) :\equiv \Sigma\ (R: A \to B \to \mProp)\ (\inUU\ p_A\ p_B\ R)
\]

Unfortunately this definition only manages to capture the idea, but does not
actually typecheck. In fact, $\_\sim_{\setoidU}\_$ should be $\mProp_1$-valued
relation, so $A \sim_{\setoidU} B$ should be a proposition. However, the
$\Sigma$ type shown above clearly isn't, since it quantifies over a type of
relations, which is not a proposition.
%
One possible solution is actually quite simple, and it just involves truncating
the $\Sigma$ type above to force it to be in $\mProp_1$.
%
\begin{align*}
  & \_\sim_{\setoidU}\_ : \setoidU \to \setoidU \to \mProp_1 \\
  & (X , p) \sim_{\setoidU} (X' , p') =
   \ \parallel \Sigma\ (R : X \to X' \to \mProp)\ (\inUU\ p\ p'\ R) \parallel
\end{align*}

We are now left to define the indexed equivalence relation on $\El$:
%
\begin{align*}
  & \_\vdash\_\sim_{\El}\_ : \{A\ B : \U\} \to A\ \sim_{\setoidU}\ B \to \El\ A \to \El\ B \to \mProp \\
  & p \vdash a \sim_{\El} b :\equiv \ ?
\end{align*}

In the definition above, $p$ has type $\parallel \Sigma\ (R: \El\,A \to \El\,B \to
\mProp)\ (...) \parallel$. If the type wasn't propositionally truncated, we could define
$p \vdash a \sim_{\El} b$ by extracting the relation out of the first component
of $p$, and apply it to $a, b$. That is, $p \vdash a \sim_{\El} b :\equiv
\pi_1\,p\,a\,b$. This would make the definition of $\_\sim_\setoidU\_$ and
$\_\vdash\_\sim_{\El}\_$ in line with how we defined $\setoidU$ and $\El$.

However, this doesn't work in our case, since the type of $p$ \emph{is}
propositionally truncated, hence it cannot be eliminated to construct a
proof-relevant object.
%
Fortunately, we can work around this limitation by defining $p \vdash x
\sim_{\El} y$ by induction on the codes $A\ B : \setoidU$, in a way that ends
up being logically equivalent to the proposition we would have obtained by
$\mathsf{proj}_1\ p\ x\ y$ if there were no truncation.
%
More precisely, we need to construct proofs that for any concrete $R$ and
$\mathsf{inR}$, the types $| (R, \mathsf{inR}) | \vdash x \sim_{\El} y$ and $R\ x\ y$
are logically equivalent. These in turn need to be defined mutually with
$\_\vdash\_\sim_{\El}\_$. We direct the interested reader to the Agda
formalization for the full details of these definitions, as they are quite
involved.

The full definition of the universe is concluded with the remaining definitions,
like $\reflu, \reflel$, etc., which can be adapted from their IR counterparts
more or less straightforwardly. The final result does not use
induction-recursion, but it's nevertheless an instance of infinitary
induction-induction. The ability to define arbitrary, infinitary
inductive-inductive types clashes, again, with our objective of keeping the
metatheory as small and simple as possible. The next step is therefore to reduce
this inductive-inductive universe to one that does not require (infinitary)
induction-induction.

\subsection{Inductive setoid universe}

This section outlines a way to encode the inductive-inductive universe of
setoids from the previous section without assuming arbitrary inductive-inductive
definitions in the metatheory.

Before turning our attention to the setoid universe, we recall the known,
systematic method to reduce finitary inductive-inductive types to inductive
families.

\subsubsection{Reducing finitary induction-induction}

It is known that finitary inductive-inductive definitions can be reduced to
inductive families \cite{iit-erasure,iit-to-ix,induction-is-enough}.
%
To illustrate the idea, let us consider a well-known example of a finitary
inductive-inductive type, the intrinsic encoding of type theory in type theory
itself. Actually, we only consider the type of contexts $\textsf{Con} :
\mType$ and the type of types $\textsf{Ty} : \textsf{Con} \to \mType$; since the
latter is indexed over the former, this is already an example of
induction-induction.

Contexts in \textsf{Con} are formed out of empty contexts $\bullet$ and context
extension $\_,\_$. Types in \textsf{Ty} are either the base type $\iota$ or
$\Pi$ types.
\begin{alignat*}{10}
  & \bullet && : \textsf{Con}                                                          &&  \iota && : (\GG : \textsf{Con}) \to \textsf{Ty}\ \GG \\
  & \_,\_ && : (\GG : \textsf{Con}) \to \textsf{Ty}\ \GG \to \textsf{Con} \hspace{5em} &&  \Pi && : \{\GG : \textsf{Con}\} (A : \textsf{Ty}\ \GG) \to \textsf{Ty}\ (\GG , A) \to \textsf{Ty}\ \GG
\end{alignat*}

The general method to eliminate induction-induction is to split the original
inductive-inductive types into a type of codes and associated well-formedness
predicates. In our \textsf{Con/Ty} example, these would be respectively given by
codes $\textsf{Con}_0, \textsf{Ty}_0 : \mType$ and predicates $\textsf{Con}_1 :
\textsf{Con}_0 \to \mType, \textsf{Ty}_1 : \textsf{Con}_0 \to \textsf{Ty}_0 \to
\mType$.

The definition of the codes and predicate types follows that of the original
inductive-inductive type, and can be derived systematically from it. More
importantly, they can be defined without induction-induction, since although
$\textsf{Con}_0$ and $\textsf{Ty}_0$ are defined mutually, their sorts are not
indexed. \\
\begin{minipage}{0.4\textwidth}
\begin{alignat*}{10}
  & \bullet_0 && : \textsf{Con}_0 \\
  & \_,_0\_ && : (\GG : \textsf{Con}_0) \to \textsf{Ty}_0 \to \textsf{Con}_0 \\
  & \iota_0 && : (\GG : \textsf{Con}_0) \to \textsf{Ty}_0 \\
  & \Pi_0 && : \textsf{Con}_0 \to \textsf{Ty}_0 \to \textsf{Ty}_0 \to \textsf{Ty}_0 \hspace{2.8em} \\
\end{alignat*}
\end{minipage}
\begin{minipage}{0.5\textwidth}
\vspace{-1.3em}
\begin{alignat*}{10}
  & \bullet_1 && : \textsf{Con}_1\ \bullet_0 \\
  & \_,_1\_ && : \forall\{\GG_0\ A_0\} \to \textsf{Con}_1\ \GG_0 \to \textsf{Ty}_1\ \GG_0\ A_0 \\
  & && \to \textsf{Con}_1\ (\GG_0 \,,_0 A_0) \\
  & \iota_1 && : \forall\{\GG_0\} \to \textsf{Con}_1\ \GG_0 \to \textsf{Ty}_1\ \GG_0\ (\iota_0\ \GG_0) \\
  & \Pi_1 && : \forall\{\GG_0\ A_0\ B_0\} \to \textsf{Con}_1\ \GG_0 \\
  & && \to \textsf{Ty}_1\ \GG_0\ A_0 \to \textsf{Ty}_1\ (\GG_0\, ,_0 A_0)\ B_0 \\
  & && \to \textsf{Ty}_1\ \GG_0\ (\Pi_0\ \GG_0\ A_0\ B_0)
\end{alignat*}
\end{minipage}
\\

We can recover the original inductive-inductive type as $\textsf{Con} :\equiv
\Sigma\ (\GG_0 : \textsf{Con}_0)\ (\textsf{Con}_1\ \GG_0)$ and $\textsf{Ty}\ \GG
:\equiv \Sigma\ (A_0 :
\textsf{Ty}_0)\ (\textsf{Ty}_1\ (\pi_1\ \GG)\ A_0)$. Recovering the constructors
is straightforward:
\begin{alignat*}{10}
  & \bullet && :\equiv (\bullet_0 , \bullet_1) \\
  & (\GG_0 , \GG_1) , (A_0 , A_1) && :\equiv ((\GG_0 \mathbin{,_0} A_0) , (\GG_1 ,_1 A_1)) \\
  & \iota\ (\GG_0 , \GG_1) && :\equiv (\iota_0\ \GG_0 , \iota_1\ \GG_1) \\
  & \Pi\ \{\GG_0 , \GG_1\}(A_0 , A_1) (B_0 , B_1) && :\equiv
    (\Pi_0\ \GG_0\ A_0\ B_0 , \Pi_1\ \GG_1\ A_1\ B_1)
\end{alignat*}

Finally, we can define eliminators/induction principles for $\textsf{Con}$ and
$\textsf{Ty}$ as just defined, by induction on the well-typing predicates.

For any inductive-inductive type $A : \mType, B: A \to \mType$, the most general
form of (dependent) eliminator is given by motives $F : A \to \mType$ and $G :
(a : A) \to (b : B a) \to F\ a \to \mType$, and the functions $\textsf{elim}_A :
(a : A) \to F\ a, \textsf{elim}_B : (a : A) \to (b : B\ a) \to
G\ a\ b\ (\textsf{elim}_A\ a)$. A simpler notion of eliminator does not require
the second component of the motive to mention the first. In particular, we have
$F : A \to \mType$, $G : (a : A) \to B\ a \to \mType$, and eliminators
$\textsf{elim}_A : (a : A) \to F\ a, \textsf{elim}_B : (a : A) (b : B\ a) \to
G\ a\ b$. Note that this elimination principle---that we call \emph{simple
  elimination} after \cite{ii}---is no longer recursive-recursive, since
$\textsf{elim}_A$ is not mentioned in the signature of $\textsf{elim}_B$.

Let us go back to our \textsf{Con}/\textsf{Ty} example. Given any dependent
algebra of $\textsf{Con}$ and $\textsf{Ty}$ with motives $C : \textsf{Con} \to
\mType$ and $T : (\GG : \textsf{Con}) \to \textsf{Ty}\ \GG \to C\ \GG \to
\mType$, the general eliminators have the following signatures:
\begin{align*}
  & \textsf{elim}_{\textsf{Con}} : (\GG : \textsf{Con}) \to C\ \GG \hspace{5em} & \textsf{elim}_{\textsf{Ty}} : \{\GG : \textsf{Con}\} (A : \textsf{Ty}\ \GG) \to T\ \GG\ A\ (\textsf{elim}_{\textsf{Con}}\ \GG)
\end{align*}

These can be derived from our encoding of $\textsf{Con}$ and $\textsf{Ty}$ via
untyped codes and well-typing predicates. The way to do it is to first define
the graph of the eliminators in the form of inductively-generated relations:
\begin{align*}
  & \textsf{data}\ \textsf{R-Con} :
    (\GG : \textsf{Con}) \to C\ \GG \to \mType \\
  & \textsf{data}\ \textsf{R-Ty} : \{\GG : \textsf{Con}\} (A : \textsf{Ty}\ \GG)
  (\gamma : C\ \GG)
  \to T\ \GG\ A\ \gamma
  \to \mType
\end{align*}

The next step is to prove that these relations are functional, by induction on
the untyped codes $\textsf{Con}_0$ and $\textsf{Ty}_0$ \cite{induction-is-enough}. From this result,
defining the eliminators is immediate.

\subsubsection{Reducing the setoid universe}\label{inductive-universe}

The reduction described in the previous section works generically for an
arbitrary finitary inductive-inductive type, thus giving a systematic way to
reduce finitary inductive-inductive definitions to inductive families. However,
it is not clear whether this method extends to \emph{infinitary}
induction-induction, of which the setoid universe defined in
Section~\ref{ii-universe} is an instance.
%
Of course, the absence of a general reduction method does not mean that we can't
reduce particular concrete instances of infinitary induction-induction, which is
exactly what we hope for our universe construction.

The obvious challenge in successfully completing this reduction is to avoid the
need for extensionality in the metatheory. In fact, consider the simple
infinitary inductive-inductive type obtained from the previous $\textsf{Con/Ty}$
example by replacing the finitary constructor $\Pi$ with an infinitary one: $\Pi
: \{\GG : \textsf{Con}\} \to (\mathds{N} \to \textsf{Ty}\ \GG) \to
\textsf{Ty}\ \GG$. Already with this simple example, we run into problems as
soon as we try to define the eliminator. One issue is that the definition of the
eliminator relies on a proof that the well-typing predicates $\inU_1,
\inUU_1$ are propositional, that is, any two of their elements are equal.
%
Without further assumptions this proof can only be done by induction, and
requires function extensionality since these predicates include higher-order
constructors.

One way to get around this is to define the well-typing predicates as
$\mProp$-valued families, rather than in $\mType$:
\begin{alignat*}{10}
  & \textsf{data}\ \inU_0 && : \mType \to \mType_1 \\
  & \textsf{data}\ \inUU_0 && : \{A\ A' : \mType\} \to (A \to A' \to \mProp) \to \mType_1 \\
  & \textsf{data}\ \inU_1 && : (A : \mType) \to \inU_0\ A \to \mProp_1 \\
  & \textsf{data}\ \inUU_1 && : \{A\ A' : \mType\} \to (R : A \to A' \to \mProp) \to \inUU_0\ R \to \mProp_1
\end{alignat*}

Using $\mProp$ avoids the issue of proving propositionality altogether, since the
predicates are now propositional by definition.
%
However, it introduces a different issue: $\inU_1$ and $\inUU_1$ give
rise to equational constraints on their indices, in the form of proofs of the
$\mProp$-valued identity type. The definition of the eliminators for $\inU$
and $\inUU$ relies on the ability to transport along these proofs, hence
the need to extend our metatheory with a primitive, strong form of transport for
$\textsf{Id}$.\footnote{Note that this issue cannot be solved by expressing the
  equational constraints with an identity type in $\mType$, since the
  well-typing predicates force it to necessarily be in $\mProp$.}

Having $\mProp$ and a strong transport principle does help to some extent.
%
However, we would still need extensionality to derive the general eliminators
for $\inU$ and $\inUU$. In fact, as explained in the previous section,
to derive the general recursive-recursive eliminators we need to prove that the
corresponding graph relations are functional, which can't be done without funext.

Luckily, it turns out that the \emph{simple} elimination principle is sufficient
for our purposes: all functions of Section \ref{ii-universe} are defined using simple mutual pattern matching without recursion-recursion.
The simple eliminator can be defined by pattern matching on
the untyped codes, and does not require extensionality or any extra principles
beyond strong transport.

Once the inductive encoding of the inductive-inductive universe is done, the
setoid universe can be defined just as in Section~\ref{ii-universe}.

\section{Conclusions and further work}\label{further-work}

We have described the construction of a universe of setoids in the setoid model
of type theory; this is given in several steps, first as an inductive-recursive
definition, then as an inductive-inductive definition, and finally as an
inductive type. Every encoding is obtained from the previous by adapting known
data type transformation methods in a novel way that accounts for the
peculiarities of our construction. The mathematical contents of this paper have
been formalized in the proof-assistant Agda (see \cite{agda-code}).

As further work, we would like to investigate a construction of the setoid
universe that does not require a strong transport rule for the proof-irrelevant
identity type. Not only to avoid unnecessary extensions to the metatheory, but
also because we don't yet know whether $\mlttp$ extended with this rule is
normalizing.
%
Indeed, previous work in this respect \cite{abel2019failure} seems to suggest
that this rule is a non-trivial addition to the metatheory.

Additionally, we want to figure out whether our inductive encoding of the setoid
universe can support universe induction. A related question is whether the
alternative definitions using induction-recursion and induction-induction can
support it.

Another question regards the relationship between SeTT \cite{mpc19} and XTT
\cite{xtt}. Both systems are syntactic representations of the setoid model with
similar design choices, like definitional proof-irrelevance. We would like to
know whether their respective notions of models are equivalent.
In particular, we would like to obtain an XTT model from a SeTT model, and vice versa. Since XTT
universes support universe induction, for one direction we would need to
extend our own universe with the same principle (see discussion in
Section~\ref{sec:setoid-model} and the previous paragraph). A further question is
whether this mapping of models is functorial.

The groupoid model of type theory \cite{groupoid} can be seen as a
generalization of the setoid model, since groupoids are essentially
proof-relevant setoids.
%
One question is therefore whether it is possible to design a type theory
internalizing the groupoid model, in the same way that SeTT represents a syntax
for the setoid model. A further question is whether such ``groupoid type
theory'' can be justified, similarly to SeTT, via a syntactic translation,
perhaps with SeTT itself as the target theory.

\bibliography{bibliography}

\end{document}
