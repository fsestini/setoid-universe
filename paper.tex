\documentclass{easychair}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{mathpartir}
\usepackage{dsfont}
\usepackage{proof}
\usepackage{tikz}
\usepackage{bbm}
\usepackage[bw]{agda}
\usetikzlibrary{cd}

\newcommand{\refl}{\textsf{refl}}
\newcommand{\GG}{\Gamma}
\newcommand{\DD}{\Delta}
\newcommand{\GD}{\Delta}
\newcommand{\R}{\textsf{R}}
\newcommand{\Id}{\textsf{Id}}
\newcommand{\coe}{\textsf{coe}}
\newcommand{\coh}{\textsf{coh}}
\newcommand{\J}{\textsf{J}}
\newcommand{\tyj}[2]{#2 : \Ty\ #1}
\newcommand{\tmj}[3]{#2 : \Tm\ #1\ #3}
\newcommand{\subj}[3]{#1 : \mathrm{Sub}\ #2\ #3}
\newcommand{\setoidU}{\mathcal{U}}
\newcommand{\ad}[1]{\AgdaFunction{#1}}
\newcommand{\Set}{\textsf{Set}}
\newcommand{\mType}{\mathbf{Type}}
\newcommand{\Prop}{\textsf{Prop}}
\newcommand{\mProp}{\mathbf{Prop}}
\newcommand{\Setoid}{\textsf{Setoid}}
\newcommand{\Con}{\mathrm{Con}}
\newcommand{\Ty}{\mathrm{Ty}}
\newcommand{\Tm}{\mathrm{Tm}}
\newcommand{\Sub}{\mathrm{Sub}}
\newcommand{\Tms}{\mathrm{Tms}}
\newcommand{\id}{\mathrm{id}}
\newcommand{\op}{\mathrm{op}}
\newcommand{\cat}[1]{\underline{\mathbf{#1}}}
\newcommand{\U}{\textsf{U}}
\newcommand{\El}{\textsf{El}}
\newcommand{\Uty}{\mathds{U}}
\newcommand{\EL}{\mathds{E}l}

\newcommand{\Type}{\mathbf{Type}}
\renewcommand{\iff}{\leftrightarrow}
\newcommand{\Nat}{\mathbb{N}}
\newcommand{\Int}{\mathbb{Z}}
\newcommand{\Rat}{\mathbb{Q}}
\newcommand{\Real}{\mathbb{R}}
\newcommand{\Bool}{\mathrm{Bool}}

\newcommand{\reflu}{\textsf{refl}_\setoidU}
\newcommand{\symu}{\textsf{sym}_\setoidU}
\newcommand{\transu}{\textsf{trans}_\setoidU}
\newcommand{\reflel}{\textsf{refl}_\El}
\newcommand{\symel}{\textsf{sym}_\El}
\newcommand{\transel}{\textsf{trans}_\El}
\newcommand{\coeel}{\textsf{coe}_\El}
\newcommand{\cohel}{\textsf{coh}_\El}
\newcommand{\equ}[2]{#1 \sim_\setoidU #2}
\newcommand{\eqel}[3]{#1 \vdash #2 \sim_\El #3}

\newcommand{\metaprop}{\mathbf{Prop}}

\newcommand{\List}{\mathrm{List}}
\newcommand{\rev}{\mathrm{rev}}

%\newtheorem{theorem}{Theorem}

\providecommand\mathbbm{\mathbb}
\def\lv{\mathopen{{[\kern-0.14em[}}}    % opening [[ value delimiter
\def\rv{\mathclose{{]\kern-0.14em]}}}   % closing ]] value delimiter
\newcommand{\eval}[1]{{\lv{#1}\rv}}

% \usepackage{amsmath}
% \usepackage{amssymb}
% %\usepackage{mathpartir}

%\usepackage{natbib}
%\setcitestyle{round}
% Note that the \doi command from the doi package doesn't enable the
% same kinds of line breaks as the command below.
\newcommand{\doi}[1]{doi:\href{http://doi.org/#1}{%
    \urlstyle{same}\nolinkurl{#1}}}

% TODO notes.
\usepackage[textsize=small]{todonotes}
\setlength{\marginparwidth}{2cm}
\newcommand{\txatodo}[1]{\todo[fancyline,color=green!20]{#1}{}}

\title{Constructing a universe for the setoid model}
\titlerunning{Constructing a universe for the setoid model}
\authorrunning{Altenkirch, Boulier, Kaposi, Sattler, Sestini}

\author{
  Thorsten Altenkirch \inst{1}\thanks{Supported by USAF grant FA9550-16-1-0029.}
\and
  Simon Boulier
\and
  Ambrus Kaposi \inst{2}
\and
  Christian Sattler\inst{1}\thanks{Supported by USAF grant FA9550-16-1-0029.}
\and
  Filippo Sestini\inst{1}
}

\institute{
  School of Computer Science, University of Nottingham, UK\\
  \email{\{psztxa,pszcs1,psxfs5\}@nottingham.ac.uk}
  \and
  E{\"o}tv{\"o}s Lor{\'a}nd University, Budapest, Hungary\\
  \email{akaposi@inf.elte.hu}
}

\begin{document}
\maketitle

\section{Introduction}

A central aspect of Type Theory is the coexistence of two notions of
equality. On the one hand definitional equality, the computational equality that
is built into the formalism. On the other hand ``propositional'' equality, the
internal notion of equality that is actually used to state and prove equational
theorems within the system. The precise balance between these two notions is at
the center of type theory research; however, it is generally understood that to
properly support formalization of mathematics in type theory, one should aim for
a notion of definitional equality that is decidable and therefore
machine-checkable, and a notion of propositional equality that is as as
extensional possible.

Two extensionality principles seem particularly desirable, in that they arguably
constitute the bare minimum for type theory to be comparable to set theory as a
foundational system for set-level mathematics, in terms of power and ergonomics.
One is function extensionality (funext), according to which functions are equal
if point-wise equal. Another is propositional extensionality (propext), equating
all propositions that are logically equivalent.

Extensional Type Theory (ETT) does support extensional reasoning to some degree,
and thus would seem a convenient setting for formalization of
mathematics. However, ETT's equality reflection makes type-checking ETT terms
computationally unfeasible, if not impossible.

On the other hand, Intensional Type Theory (ITT) has nice computational
properties that can make it more suitable for computer implementation, but as
normally defined [cite Martin-L\"of paper?] it lacks extensionality.
%
It is known from model constructions that extensional principles like funext are
consistent with ITT.
%
Moreover, ITT extended with uniqueness of identity proofs (UIP) and funext is
known to be as powerful as ETT [cite hofmann]. These principles can be added as
axioms, however destroying some computational properties of ITT such as
canonicity.

What we would like instead is a formulation of ITT that supports the
aforementioned extensionality principles, while retaining convenient
computational properties like canonicity and decidability of type checking.
%
Unfortunately, one can show that whenever identity types are defined according
to Martin-Loef's inductive definition, there is no hope to have canonicity and
funext coexist.
%
The first step towards a solution is to give up the idea of propositional
equality as single type family inductively generated by reflexivity. Instead,
equality should be \emph{specific} to each type former in the type theory, or in
other words, every type former should be introduced alongside an explanation of
what counts as equality for its elements. In this setting, function
extensionality can simply be introduced as the chosen notion of equality on
function types.

This conception of types together with their notion of equality goes back to the
notion of \emph{setoids} or \emph{Bishop sets}. A setoid is simply a set
equipped with a propositional equivalence relation. Setoids provide a quite
natural and useful semantic domain in which to interpret type theory. The first
setoid model was constructed to show consistency of funext for ITT [cite]. This
consistency result is implied by the observation that UIP and funext hold in the
setoid model. Moreover, it was shown by Altenkirch [cite] that is the model
construction is carried out in a metatheory with a universe of strict
(definitionally proof-irrelevant) propositions, it is possible to define a
univalent universe of propositions, therefore satisfying propositional
extensionality. The setoid model thus satisfies all the extensionality
principles that we would like to extend ITT with. The question is whether there
exists a version of ITT that supports setoid reasoning, and hence the forms of
extensionality enables by it.

This question was revisited and answered in Altenkirch et al. [cite]. In this
paper, the authors define SeTT an extension of intensional MLTT + Prop with
constructs for setoid reasoning, where funext and propext hold by
definition. Moreover, they justify SeTT via a syntactic translation, after
observing that this is made possible by the strictness of the model (every
equation holds definitionally). This is in contrast with other type theories
based on the setoid model, like OTT [cite] and XTT [cite], which instead rely on
ETT as metatheory for their justification. A major contribution of SeTT is
therefore to provide a way to bootstrap extensionality, by translating it into a
small core intensional theory by means that do not require extensionality to
begin with.

The current formulation of SeTT is already a rich theory. However, its
introspection capabilities are currently lacking, as they are limited to the
univalent universe of propositions. We would like to internalise the notion of
type in SeTT, thus extending the theory with a universe of setoids.
%
This brings up several questions, one of which has to do with the notion of
equality with which the universe should come equipped. The universe of setoids
is itself a setoid (as any type is), so it certainly cannot be a univalent
universe, since a univalent setoid would be a groupoid rather than a setoid.
%
Another question asks how one can justify such universe in the setoid model. In
particular what principles, are needed from the metatheory in order to define
the universe.

\paragraph{Contributions}

This paper documents our work towards the construction of a universe of setoids
inside the setoid model, and tries to answer these and other questions related
to the design and implementation of this construction. Our main contribution is
the definition of the universe in the setoid model; this is initially given as
an inductive-inductive-recursive definition, which is then translated firstly to
an inductive-inductive definition, and secondly to a purely inductive type. As a
consequence, we show that we only need to assume indexed W-types in the
metatheory (along with some obligatory basic tools like $\Sigma$ and $\Pi$
types) to justify the universe.

\paragraph{Structure of the paper}

We begin by describing the metatheory that we will use throughout the paper, in
Section~\ref{sec:metatheory}. In Section~\ref{sec:setoid-model}, after briefly
recalling the abstract notion of models of Type Theory known as categories with
familes (CwF), we outline Altenkirch's setoid model of Type Theory in the
variant used in \cite{mpc19}. We then show how the model has been turned into
Setoid Type Theory in Section~\ref{sett}.

In Section~\ref{setoid-universe} we provide the actual construction of the
setoid universe in the setoid model. In Section~\ref{ir-universes} we first
recall the well known inductive-recursive definition of universes in Type
Theory, and the way these can be turned into a construction that does not
require induction-recursion.
%
We then provide, in Section~\ref{ir-setoid-universe}, a first complete
definition of the setoid universe using a quite complex form of
induction-recursion. This is followed by an alternative definition of the
universe in Section~\ref{ii-universe}, that does not rely on induction-recursion
but instead on infinitary induction-induction.
%
Further reductions of this inductive-inductive universe to even simpler forms,
in addition to other long term goals, are discussed in
Section~\ref{further-work}.


\subsection{Related work}

TODO

\section{$MLTT^{Prop}$}\label{metatheory}

This section describes $MLTT^{Prop}$, the metatheory in which the model
construction described in the following sections takes place. We employ Agda
notation for metatheoretic terms throughout the paper.

One aspect of the metatheory that we pay attention to is it's minimality, as we
want to keep it as simple as possible. In particular, we want to avoid having to
assume strong definition schemas that go beyond inductive families.

$MLTT^{Prop}$ is an intensional type theory in the style of Martin-L\"of Type
Theory with $\Pi, \Sigma, \textsf{Bool}, \mathbf{0}, \mathbf{1}$, and a universe
of strict propositions $\mProp$. $\Sigma$ types are defined negatively by
pairing $\_,\_$ and projections $\pi_1, \pi_2$. We also have definitional $\eta$
rules for $\Pi, \Sigma$, and $\mathbf{1}$ types. Propositions can be lifted to
types via $\textsf{Lift} : \mProp \to \mType$.

%% The universe of propositions is
%% inhabited by false $\bot$ and propositional truncation $\|\_\| : \mType \to
%% \mProp$.

We also require indexed W-types, both in $\mType$ and $\mProp$:

\begin{align*}
  W & : (S : \mType) \to (S \to \mType) \to \mType \\
  W_p & : (S : \mType) \to (S \to \mType) \to \mProp
\end{align*}

From $W_p$ we can define propositional truncation:

\begin{align*}
  & \|\_\| : \mType \to \mProp \\
  & |\_| : \{A : \mType \} \to A \to \| A \| \\
  & \textsf{elim}_{\|\_\|} : \{P : \mProp \} \to (A \to P) \to \| A \| \to P
\end{align*}

In addition to the above type formers in $\mType$, we will need the
propositional versions of $\mathbf{1}$, $\Pi$, and $\Sigma$; however these can
be defined from their $\mType$ counterparts via truncation. That is, given $P :
\mProp$ and $Q : P \to \mProp$:

\begin{align*}
  \Pi_p\ P\ Q & :\equiv \| \Pi\ (\textsf{Lift} \ P)\ (\textsf{Lift} \circ Q \circ \textsf{unlift}) \| \\
  \Sigma_P\ P\ Q & :\equiv \| \Sigma\ (\textsf{Lift} \ P)\ (\textsf{Lift} \circ Q \circ \textsf{unlift}) \| \\
  \mathbf{1}_p & :\equiv \| \mathbf{1} \|
\end{align*}

Finally, we will assume the presence of an identity type in the style of
Martin-L\"of's inductive identity type. The main difference is that our identity
type is a $\mProp$-valued relation. Naturally, we also have a \textsf{transp}
combinator representing the corresponding elimination principle.

\begin{align*}
  & \textsf{Id} : \{A : \mType \} \to A \to A \to \mProp \\
  & \textsf{refl} : \{A : \mType \} (a : A) \to \textsf{Id}\ a\ a \\
  & \textsf{transp} : \{A : \mType \} (C : A \to \mType) \{a_0\ a_1 : A\} \to \textsf{Id}\ a_0\ a_1 \to C\ a_0 \to C\ a_1
\end{align*}

Note that this
represents a strong elimination principle, as it allows to eliminate a strict
proposition into arbitrary types. Indeed, the reason why we must assume this
identity type as primitive is because, even though we could have defined
\textsf{Id} from $W_p$, \textsf{transp} would not be definable from $W_p$
elimination. \todo{what is the justification for this?}

\subsection{Formalization}

A universe of strict propositions has been recently added to the Agda proof
assistant [cite], thus making $MLTT^{Prop}$ a subset of Agda. In fact, most of
the developments presented here have been formalized and proof-checked using
Agda extended with strict propositions.
%
For convenience, we also slightly deviate from $MLTT^{Prop}$ both in the paper
and in the formalization, for instance by relying on pattern matching instead of
eliminators, and using primitive versions of $\mProp$-valued $\Pi$ and $\Sigma$
instead of their derived forms. We operate under the assumption that everything
can be equivalently carried out in $MLTT^{Prop}$, although we haven't fully
checked all the necessary details.

\section{Setoid model}\label{setoid-model}

%% The setoid interpretation gives rise to a model of a type theory with functional
%% and propositional extensionality. It is thus a way to explain extensionality in
%% a type-theoretic and computationally adequate way \cite{setoid-model}. 

By \emph{setoid model} we intend a class of models of Type Theory where
contexts/closed types are interpreted as setoids, i.e. sets with an equivalence
relation, and dependent types are interpreted as dependent/indexed setoids.
%
A setoid model was first given for intensional Type Theory by M. Hofmann in
\cite{hofmann-ext-int}, in order to give a semantics to extensionality
principles such as function and propositional extensionality. Here we consider
a similar model construction due to Altenkirch \cite{setoid-model}.
%
The peculiarity of this model is that it is presented in a type theoretic and
intensional metatheory which includes a strict universe of propositions.
%
The use of strict propositions to define the setoid equivalence relations makes
this model \emph{strict}. A strict model is one where every equation holds
definitionally. The setoid model thus defined validates function extensionality,
a univalent universe of propositions, and quotient types. Therefore, it provides
a way to bootstrap and ``explain'' extensionality, since the model construction
effectively gives an implementation of various extensionality principles it in
terms of a small, entirely intensional type theory.

\subsection{Setoid model as a CwF}

As any model of Type Theory, the setoid model can be framed categorically as a
category with families (CwF) with extra structure for the various type and term
formers. The core structure of a CwF can be given as the following signature:

\begin{align*}
  \Con &: \mType \\
  \Ty &: (\GG : \Con) \to \mType \\
  \Sub &: (\GG \GD : \Con) \to \mType \\
  \Tm &: (\GG : \Con) \to \Ty\ \GG \to \mType
\end{align*}

In our presentation of the setoid model, contexts are given by setoids, that is
types together with an equivalence relation.

\[
\infer{
  \begin{aligned}
    & | \GG | : \mType \\
    & \GG^\sim : | \GG | \to | \GG | \to \mProp \\
    & \textsf{refl}\ \GG : (\gamma : | \GG |) \to \GG^\sim\,\gamma\,\gamma \\
    & \textsf{sym} \ \GG : \forall\{\gamma_0\ \gamma_1\} \to \GG^\sim\,\gamma_0\,\gamma_1
    \to \GG^\sim\,\gamma_1\,\gamma_0 \\
    & \textsf{trans} \ \GG : \forall\{\gamma_0\ \gamma_1\ \gamma_2\}
    \to \GG^\sim\,\gamma_0\,\gamma_1
    \to \GG^\sim\,\gamma_1\,\gamma_2
    \to \GG^\sim\,\gamma_0\,\gamma_2
  \end{aligned}
}{
  \GG : \Con
}
\]

Types in a context $\GG$ are given by setoid morphisms from $\GG$ to the
(strict) category of setoids. The definition can be unfolded as follows.

\[
\infer{
  \begin{aligned}
    & | A | : | \GG | \to \mType \\
    & A^\sim : \{\gamma_0\ \gamma_1 : | \GG |\}
    \to \GG^\sim\ \gamma_0\ \gamma_1 \to | A | \gamma_0 \to | A | \gamma_1 \to \mProp \\
    & ... \\
    & \textsf{coe} : \forall\{\gamma_0\ \gamma_1 : | \GG |\} \to \GG^\sim\ \gamma_0\ \gamma_1 \to | A | \gamma_0 \to | A | \gamma_1 \\
    & \textsf{coh} : \forall\{\gamma_0\ \gamma_1 : | \GG |\} \ (p : \GG^\sim\ \gamma_0\ \gamma_1) (a : | A | \gamma_0)
    \to A^\sim\,p\,a\,(\textsf{coe}\,A\,p\,a) \\
  \end{aligned}
}{
  A : \Ty\ \GG
}
\]

This definition of types in the setoid model is different from the one in [cite
  LICS 99 paper], but it is equivalent to it [cite]. The main difference here is
in the use of heterogeneous equality in the definition of types.

Substitutions are interpreted as functors between the corresponding setoids,
whereas terms of type $A$ in context $\GG$ are sections of the type seen as a
setoid fibration $\GG . A \to \GG$. Note that we only need to include components
for the functorial action on objects and morphisms, since the functor laws
follow from proof-irrelevance in the metatheory, and thus hold definitionally.

\[
\infer{
  \begin{aligned}
    & | \sigma | : | \GG | \to | \GD | \\
    & \sigma^\sim : \forall\{\rho_0\, \rho_1\} \to \GG^\sim\, \rho_0\, \rho_1 \to \GD^\sim\, (|\sigma|\rho_0)\, (|\sigma|\rho_1)
  \end{aligned}
}{
  \sigma : \Sub\ \GG\ \GD
}
\]

\[
\infer{
  \begin{aligned}
    & | t | : (\gamma : | \GG |) \to | A | \, \gamma \\
    & t^\sim : ...
  \end{aligned}
}{
  t : \Tm\ \GG\ A
}
\]

As defined, we can show that the setoid model validates the usual basic type
formers ($\Pi, \Sigma$, etc.), including function extensionality and a universe
of strict propositions satisfying propositional extensionality [cite LICS
  99]. Note that we don't need neither identity types nor inductive types
(W-types) in the metatheory to achieve this. However, W-types are needed when
constructing the setoid universe in the next sections.

\subsection{Setoid Type Theory}\label{sett}

The setoid model presented in the previous section is peculiar in several
ways. One is that it can be presented in a very small type theoretic
metatheory. The other important aspect is that it is \emph{strict}, namely every
equation of the original syntax holds by definition in the semantics. One
advantage of strict models is that they can be turned into \emph{syntactic
  translations}, in which syntactic objects of the source theory are interpreted
as their counterparts in another \emph{target} theory. In the case of the setoid
model, this gives rise to a \emph{setoid translation}, where source contexts are
interpreted as target contexts together with a target type representing the
equivalence relation, and so on.\todo{maybe expand this?}%
\footnote{%
Semantically, this translation corresponds to a model construction, in particular a functor from the category of models of the target theory to the category of models of what will be Setoid Type Theory.
Since the setoid translation is structural in the context component, we can work with models in the style of categories with families rather than contextual categories.
}

A setoid translation is used in \cite{mpc19} to justify Setoid Type Theory
(SeTT), an extension of $MLTT^{Prop}$ (without W-types) with equality types for
contexts and dependent types that reflect the setoid equality of the model in
the syntax.

We recall the rules of SeTT that extend $MLTT^{Prop}$ below, but with a
variation. Whereas the equality types in \cite{mpc19} are stated as elements of
the universe of propositions internal to SeTT itself, we here state the context
equalities as elements of the external, metatheoretic universe
$\mProp$. Equality on dependent types is defined as before.

We have a universe of propositions $\Prop$ defined as follows:

\[
\infer{
  \Prop : \Ty\ \GG
}{
  \GG : \Con
}
\qquad
\infer{
  \underline{P} : \Ty\ \GG
}{
  P : \Tm\ \GG\ \Prop
}
\]

Equality type constructors for contexts and dependent types internalize the idea
that every context and type comes equipped with a setoid equivalence
relation. As in the model, equality for dependent types is indexed over context
equality.

\[
\infer{
  \GG^\sim\ \rho_0\ \rho_1 : \metaprop
}{
  \GG : \Con \qquad \subj{\rho_0, \rho_1}{\DD}{\GG}
}
\qquad
\infer{
  A^{\sim}\ \rho_{01}\ a_0\ a_1 : \Tm\ \DD\ \Prop
}{
  \deduce{
    a_0 : \Tm\ \DD\ A[\rho_0] \qquad a_1 : \Tm\ \DD\ A[\rho_1]
  }{
    A : \Ty\ \GG \qquad \rho_{01} : \GG^{\sim}\ \rho_0\ \rho_1
  }
}
\]

We have rules witnessing that these are indeed equivalence relations. We only
recall reflexivity:

\[
\infer{
  \textsf{R}\ \rho : \GG^\sim\ \rho\ \rho
}{
  \rho : \Sub\ \GD\ \GG
}
\qquad
\infer{
  \textsf{R}\ a : \Tm\ \GG\ \underline{A^\sim\ (\textsf{R}\ \rho)\ a\ a}
}{
  A : \Ty\ \GG
  \qquad
  \rho : \Sub\ \GD\ \GG
  \qquad
  a : \Tm\ \GD\ A[\rho]
}
\]

In addition, we also have rules representing the fact that every construction in
SeTT respects setoid equality, so that we can transport along any such equality:

    \[
    \infer{
      \deduce{
        \tmj{\GD}{\coh_A\ p\ a}{\underline{A^\sim\ p\ a\ (\coe_A\ p\ a)}}
      }{
        \tmj{\GD}{\coe_A\ p\ a}{A[\rho_1]}
      }
    }{
      \tyj{\GG}{A} \qquad \subj{\rho_0, \rho_1}{\GD}{\GG} \qquad
      p : \GG^\sim\ \rho_0\ \rho_1\qquad
      \tmj{\GD}{a}{A[\rho_0]}
    }
    \]

Notably, equality constructors in SeTT compute definitionally on concrete type
formers. In particular, they compute to their obvious intended meaning, so that
an equality of pairs is a pair of equalities, an equality of functions is a map
of equalities, and so on. From this, we get definitional versions of function
and propositional extensionality.
%
\begin{align*}
  & (\Pi\ A\ B)^\sim\ p\ f_0\ f_1 = ... \\
  & (\Sigma\ A\ B)^\sim\ p\ (a_0, b_0)\ (a_1, b_1) = ... \\
  & \Prop^\sim\ p\ P\ Q = ...
\end{align*}

We can easily recover the usual Martin-L\"of identity type from setoid equality,
with transport implemented via coercion.

\[
\infer{
  \textsf{Id}_A\ a_0\ a_1 :\equiv A^{\sim}\ (\R\ \GG)\ a_0\ a_1 : \Tm\ \GG\ \Prop
}{
  \tyj{\GG}{A} \qquad \tmj{\GG}{a_0, a_1}{A}
}
\]
\[
\infer{
  \textsf{transp}\ P\ p\ t :\equiv
    \coe\ P\ (\textsf{R}\ \textsf{id} , p)\ t : \Tm\ \GG\ P[a_1]
}{
  P : \Ty\ (\GG . A)
  \qquad
  p : \Tm\ \GG\ (\Id\ A\ a_0\ a_1)
  \qquad
  t : \Tm\ \GG\ P[a_0]
}
\]

Note that contractibility of singletons holds in SeTT by UIP and the computation
rules of equality on $\Sigma$ types. Hence, the J eliminator can also be
derived.

\section{Universe of setoids}\label{setoid-universe}

In its current form, SeTT is already rich and interesting in its own right.
However, as pointed out in the introduction, it is also seriously limited by the
lack of a universe internalizing the notion of types beyond propositions, that
is, a universe of setoids. Our goal is to extend SeTT with such universe; since
SeTT is a direct syntactic reflection of the setoid model, this essentially
amounts to showing that a universe of setoids with the necessary structure and
equations can be constructed within the setoid model. This opens several
questions and possible design choices.

A first fundamental consideration has to with the very definition of the setoid
universe: as any type in the setoid model, this universe must be a setoid and
thus come equipped with an equivalence relation. However, unlike the already
existing universe of propositions, a universe of setoids cannot be univalent,
since this would force it to be a groupoid. Instead, we can define the relation
so that it reflects a simpler syntactic equality of codes.

Another question has to do with the metatheoretic tools required to carry out
the construction of the universe. In fact, one of the main aspects of the setoid
model construction recalled in Section TODO and shown originally in [cite LICS
  99] is that it can be carried out in a very small type theoretic metatheory,
thus providing a way to reduce extensionality to a small intensional core.
%
In extending the setoid model with a universe, we would like this property to
still hold, hence it is of primary concern to reduce to a minimum the extensions
required in the metatheory, so to keep it as small as possible.

A known and established method for constructing universes in Type Theory uses
induction-recursion (IR), a definition schema developed by Dybjer
[cite]. Inductive-recursive definitions can be found throughout the literature
on type theory, from the already mentioned type theoretic universes, including
the original formulation a la Tarski by Martin-L\"of [cite], to metamathematical
tools like computability predicates [cite].

Although universe constructions in Type Theory---including our own setoid
universe---are naturally presented as inductive-recursive definitions, they
may not necessarily require a metatheory that supports induction-recursion. In
fact, it is possible to reduce some instances of induction-recursion to plain
induction (more specifically, inductive families), including some universe
definitions. We recall this reduction in Section TODO.

%% However, we would prefer not to be forced to assume inductive-recursive types,
%% or IR in general, in the basic type theory which is the target of the setoid
%% translation. This is because the point of the translation is to explain a
%% complex system in terms of a very simple, well understood core, and we think
%% introducing IR would go against this goal.

Other design choices on the setoid universe are less essential, but still
require careful consideration. For instance, one question is whether the setoid
universe should support elimination, thus exposing the inductive structure of
the codes. Universe elimination is known to be inconsistent with univalence. As
it turns our, univalence is not an issue in our case; nevertheless it is not
immediately clear if the elimination principle can be justified by the
semantics.

Another choice is whether to include codes for other universes, besides the
usual type formers. One could have $\Prop$ be a code in the setoid universe,
rather than a type. Moreover, the universes could form a hierarchy, where the
universe at level $i$ is an element of the universe of level $i+1$. Another
option is whether to make the hierarchy cumulative.

%% In the next section, we recall the inductive-recursive construction of universes
%% in type theory, as well as lay out the process by which such construction can be
%% turned to one that only relies on inductive families. In Section TODO, we give a
%% first inductive-recursive definition of the universe of setoids. After that we
%% will see if and how such IR definition can be turned into one that does not rely
%% on IR.

Yet another choice is whether to have two separate sorts, one for propositions
and one for sets (with propositions convertible to sets) or a single sort of
types (sets), with propositions given by elements of a universe of proposition,
which is a (large) type. We have chosen to present the second option to fit with
the standard notion of (unisorted) CwF. However, this has downsides: to even
talk about propositions, we need to have a notion of large types. The first
option is more symmetric: we can have parallel hierarchies for propositions and
sets.

\subsection{Inductive-recursive universes in Type Theory}\label{ir-universes}

An inductive-recursive universe is given by a type of codes $\U : \mType$, and a
family $\El : \U \to \mType$ that assigns, to each code corresponding to some
type, the meta-theoretic type of its elements. The resulting definition is
inductive-recursive because the inductive type of codes is defined
simultaneously with the recursive function $\El$.

As an example, consider the following definition of a small universe with
booleans and $\Pi$ types.

\begin{align*}
  & \textsf{data}\ \U\ : \mType \\
  & \quad \textsf{bool} : \U \\
  & \quad \textsf{pi} : (A : \U) \to (\El\ A \to \U) \to \U \\
  & \El\ \textsf{bool} = \mathbbm{2} \\
  & \El\ (\textsf{pi}\ A\ B) = (a : \El\ A) \to \El\ (B\ a)
\end{align*}

%% Note that $\U$ is defined to be in $\mType_1$ rather than $\mType$. This is
%% because... \todo{TODO add explanation}.

Induction-recursion is arguably the nicest and more natural way to define
internal universes in Type Theory, however it is not always required.
%
We can translate basic instances of induction-recursion into inductive families
using the equivalence of $I$-indexed families of types and types over $I$
(that is, $\mType_i \to I$).

Following this, we seen that we can actually encode the universe above as an
inductive type $\ad{in-U}$ that \emph{carves out} all types in $\Set$ that are
in the image of $\El$. In other words, $\ad{in-U}$ is a predicate that holds for
any type that would have been obtained via $\El$ in the usual
inductive-recursive definition. As $\El$ is indexed on the type of codes, the
definition of $\ad{in-U}$ quite expectedly reflecs the inductive structure of
codes.
%
\begin{align*}
  & \textsf{data}\ \ad{in-U} : \mType \to \mType_1 \\
  & \quad \textsf{inBool} : \textsf{in-U}\ \mathbbm{2} \\
  & \quad \textsf{inPi}
  :  \{A : \mType\} \{B : A \to \mType\}\\
  & \ \qquad \to \ad{in-U}\ A
  \to ((a : A) \to \ad{in-U}\ (B\ a))
  \to \ad{in-U}\ ((a : A) \to (B\ a))
\end{align*}
Using this $\U$ and $\El$ can be given as follows:
\begin{align*}
  \U & = \Sigma (A : \mType)\ (\textsf{in-U}\ A) \\
  \El & = \textsf{proj}_1
\end{align*}

Note that this construction gives rise to a universe in $\mType_1$, rather than
$\mType$, since the definition of $\U$ quantifies over all possible sets. This
also means that a metatheory with at least one universe is required for this
construction.

\subsection{A first definition of the setoid universe}\label{ir-setoid-universe}

In this section we give a first definition of the setoid universe, as a direct
generalization of the simple inductive-recursive definition just shown. We only
consider a very small universe with unit type $\mathds{1}$ and $\Pi$ for
simplicity; a more realistic universe can be found in the Agda formalization,
and includes more type formers.

To construct the universe of setoids in the setoid model, we first of all need
to define a type $\Uty : \Ty\ \GG$ for every $\GG : \Con$, and for every $A :
\Tm\ \GG\ \Uty$ a type $\mathds{E}l\ A : \Ty\ \GG$. Recalling Section TODO,
these are essentially record types made of several components. Since $\Uty$ is a
closed type, it requires the same data of a setoid; in particular, we need a type
of codes together with an equivalence relation reflecting equality of codes:
%
\begin{align*}
  & \textsf{data} \ \setoidU : \mType_1 \\
  & \_\sim_\setoidU\_ : \setoidU \to \setoidU \to \mProp_1
  %% & \El : \setoidU \to \Set \\
  %% & \_\vdash\_\sim_\El\_ : \{a\ a' : \setoidU\} \to a \sim_\setoidU a' \to \El\ a \to \El\ a' \to \Prop
\end{align*}
%
in addition to proofs that these are indeed equivalence relations
%
\begin{align*}
  & \textsf{refl}_\setoidU : (A : \setoidU) \to \equ{A}{A} \\
  & \textsf{sym}_\setoidU : \equ{A}{B} \to \equ{B}{A} \\
  & \textsf{trans}_\setoidU : \equ{A}{B} \to \equ{B}{C} \to \equ{A}{C}
\end{align*}

To define $\EL$, we need a family of setoids indexed over the universe. In other
words, a way to assign to each code in the universe a carrier set and an
equivalence relation.
%
\begin{align*}
  & \El : \setoidU \to \Set \\
  & \_\vdash\_\sim_\El\_ : \{a\ a' : \setoidU\} \to a \sim_\setoidU a' \to \El\ a \to \El\ a' \to \Prop
\end{align*}

Note that $\eqel{\_}{\_}{\_}$ is indexed over equality on the universe, because
$\El$ is a setoid morphism, hence in particular it must respect the setoid
equality of $\setoidU$.
%
We also require data and proofs that make sure we get setoids out of $\El$:

\begin{align*}
  & \textsf{refl}_\El : (A : \setoidU) (x : \El\ A) \to \eqel{\reflu\ A}{x}{x} \\
  & \textsf{sym}_\El : \eqel{p}{x}{x'} \to \eqel{\symu\ p}{x'}{x} \\
  & \textsf{trans}_\El : \eqel{p}{x}{x'} \to \eqel{q}{x'}{x''} \to \eqel{\transu\ p\ q}{x}{x''} \\
  & \coeel : \equ{A}{B} \to \El\ A \to \El\ B \\
  & \cohel : (p : \equ{A}{A'}) \ (x : \El\ A) \to \eqel{p}{x}{\coeel\ p\ x}
\end{align*}

%% \todo{QIIT II LICS paper. this part is already in the HIIT paper}

We give an inductive definition of $\setoidU$, mutually with a recursive
definition of everything else. Below we only show the more interesting definitions of $\setoidU$ and $\El$:
%
\begin{align*}
  & \textsf{data}\ \setoidU : \Set_1 \\
  & \quad \textsf{one} : \setoidU \\
  %% Πs : (a : U i)(b : El a → U i)
     %% (refb : {x x' : El a}(x~ : refU a ⊢ x ~El x') → b x ~U b x') → U i
  & \quad \textsf{pi}
  :  (A : \setoidU) (B : \El\ A \to \setoidU)\\
  & \ \qquad \to (\{x\ x' : \El\ A\} \to \textsf{refl}_\setoidU\ A \vdash x \sim_\El x' \to B\ x \sim_\setoidU B\ x')
  \to \setoidU
\end{align*}
%
\begin{align*}
  & \El\ \textsf{one} :\equiv \textbf{1} \\
  & \El\ (\textsf{pi}\ A\ B\ h) :\equiv \\
  & \qquad \Sigma\ (f : (a : \El\ A) \to \El\ (B\ a)) \\
  & \qquad \quad
  (\forall\{x\ x'\}(p : \eqel{\reflu\ A}{x}{x'}) \to \eqel{h\ p}{f\ x}{f\ x'})
\end{align*}

Note that in the definition of $\setoidU$ we require that the family $B : \El\ A
\to \setoidU$ be a setoid morphism, respecting the setoid equalities involved.
%
This choice is crucial for the definition of $\El$ to go through, in particular
since we eliminate the code for $\Pi$ types into the setoid of functions that
map equal elements to equal results. To state this mapping property we need to
compare elements in different types, coming from applying $f$ to different
arguments $x$ and $x'$. We know that $x$ and $x'$ are equal, but to conclude
$\equ{B\ x}{B\ x'}$ we need to know that $B$ respects setoid equality. This is
exactly what we get from our definition of $\setoidU$.

[todo... explanation]
%
\begin{align*}
  & | \Uty | :\equiv \lambda\, \gamma . \, \setoidU \\
  & \Uty^\sim :\equiv \lambda \,p\, x\, y . \,x \sim_{\setoidU} y \\
  & \textsf{refl}\ \Uty :\equiv \reflu \\
  & ... \\
  & \textsf{coe}\ \Uty :\equiv \lambda\,p\,a . \, a \\
  & \textsf{coh}\ \Uty :\equiv \lambda\,p . \, \reflu
\end{align*}

Given $A : \Tm\ \GG\ \Uty$, we define $\EL\ A$ as follows:
%
\begin{align*}
  & | \EL\ A | :\equiv \lambda \, \gamma . \, \El\ (| A | \,\gamma) \\
  & (\EL\ A)^\sim :\equiv \lambda \, p \, x \, y . \, \eqel{A^\sim\,p}{x}{y} \\
  & \textsf{refl}\ (\EL\ A) :\equiv \reflel \\
  & ... \\
  & \textsf{coe}\ (\EL\ A) :\equiv \lambda\,p.\, \textsf{coe}_{\El}\,(A^\sim\,p) \\
  & \textsf{coh}\ (\EL\ A) :\equiv \lambda\,p.\, \textsf{coh}_{\El}\,(A^\sim\,p)
\end{align*}

We can show that $\Uty$ is closed under $\Pi$ types and \textsf{Bool}, including
$\beta$ and $\eta$ laws. Moreover, all the necessary equations hold
definitionally in the metatheory.

This gives a complete definition of a universe of setoids. However, as already
pointed out, this definition uses induction-recursion. Moreover, the kind of
recursion involved in this definition is particularly complex, since TODO. It is
not clear whether this definition can be reduced to simpler, better understood
notions of induction-recursion like in [dybjer-setzer]. Nevertheless, even the
need to extend the metatheory with simple forms of induction-recursion goes
against our objective to keep the metatheory as small and essential as possible.

The goal of the next section is therefore to transform the
inductive-recursvie-recursive definition ourlined above to one that doesn't use
induction-recursion.
%
This transformation is inspired by the well-known trick to eliminate
induction-recursion described in Section X, but modified in a novel way to
account for the presence of $\mProp$-valued types. To our knowledge, this is the
first time this reduction trick is applied to an inductive-recursive type of
this kind.

%% The above definition of the setoid universe relies on both induction-recursion
%% and induction-induction. Although happily accepted by Agda, we don't fully
%% understand the meaning of this combination, so we would like to find an
%% equivalent definition that does not rely on it. The goal of the next sections is
%% therefore to get to such an alternative definition. This is done by first
%% transforming the inductive-inductive-recursive definition to one that doesn't
%% use induction-recursion, and secondly by reducing the induction-induction to
%% inductive families.

%% Our transformation of the inductive-inductive-recursive definition is inspired
%% by the well-known trick described in Section X, but modified in a novel way to
%% account for the presence of induction-induction and $\mProp$-valued types. To
%% our knowledge, this is the first time this reduction trick is applied to an
%% inductive-recursive type of this complexity.

\subsection{Inductive-inductive universe}\label{ii-universe}

The reduction of the IR universe to induction works, conceptually, as in the
small example of Section X.
%
However, in addition to $\ad{in-U}$ for defining $\U$, we also introduce a
family $\ad{in-U∼}$ of binary relations between types in the universe, from
which we then define $\_\sim_{\setoidU}\_$.
%
\begin{align*}
  & \textsf{data}\ \ad{in-U} : \Set \to \Set_1 \\
  & \textsf{data}\ \ad{in-U∼} : \{A\ A' : \Set\} \to \ad{in-U}\ A \to \ad{in-U}\ A' \to (A \to A' \to \Prop) \to \Set_1
\end{align*}

Note that $\ad{in-U}$ appears in the sort of $\ad{in-U∼}$. Since these types are
mutually defined, this is an instance of \emph{induction-induction}, a schema
that allows the definition of a type mutually with other types that contain the
first one in their signature [cit]. The main example of induction-induction can
be found in intrinsic definitions of type theory in type theory [cite tt in tt].

As in the universe example in Section TODO, we now define $\setoidU$ as a
$\Sigma$ type, and $\El$ as the corresponding first projection.

\begin{align*}
  & \setoidU : \mType_1 \\
  & \setoidU = \Sigma\ (X : \mType)\ (\ad{in-U}\ X) \\
  & \El : \setoidU \to \mType \\
  & \El = \textsf{proj}_1
\end{align*}

What is left now is to define the setoid equality relation on the universe, as
well as the setoid equality relation on $\El\ A$ for any $A$ in $\setoidU$.
%
Two codes $A, B$ in the universe $\setoidU$ are equal when there exists a setoid
equivalence relation on their respective sets $\El\ A$ and $\El B$. Intuitively,
since elements of a setoid are only ever compared to elements of the same
setoid, this should only be possible if $A, B$ are codes for the same setoid,
that is, if $A \sim_{\setoidU} B$. Existence and well-formedness of such
relations is expressed via the type $\ad{in-U~}$ just defined, hence we would
expect $A \sim_{\setoidU} B$ to be defined as follows:

\[
A \sim_{\setoidU} B :\equiv \Sigma (R: \El\,A \to \El\,B \to \mProp)(\ad{in-U∼}\ (\pi_2\,A)\ (\pi_2\,B)\ R)
\]

or, using pattern matching:

\[
(A, p_A) \sim_{\setoidU} (B, p_B) :\equiv \Sigma (R: A \to B \to \mProp)(\ad{in-U∼}\ p_A\ p_B\ R)
\]

Unfortunately this definition only manages to capture the idea, but does not
actually typecheck. In fact, $\_\sim_{\setoidU}\_$ should be $\Prop_1$-valued
relation, so $A \sim_{\setoidU} B$ should be a proposition. However, the
$\Sigma$ type shown above clearly isn't, since it quantifies over a type of
relations, which is not a proposition.
%
One possible solution is actually quite simple, and it just involves truncating
the $\Sigma$ type above to force it to be in $\Prop_1$.
%
\begin{align*}
  & \_\sim_{\setoidU}\_ : \setoidU \to \setoidU \to \Prop_1 \\
  & (X , p) \sim_{\setoidU} (X' , p') =
   \ \parallel \Sigma\ (R : X \to X' \to \Prop)\ (\ad{in-U∼}\ p\ p'\ R) \parallel
\end{align*}

We are now left to define the indexed equivalence relation on $\El$:
%
\begin{align*}
  & \_\vdash\_\sim_{\El}\_ : \{A\ B : \U\} \to A\ \sim_{\setoidU}\ B \to \El\ A \to \El\ B \to \mProp \\
  & p \vdash a \sim_{\El} b :\equiv \ ?
\end{align*}

In the definition above, $p$ has type $\|| \Sigma (R: \El\,A \to \El\,B \to
\mProp)(...) \||$. If the type wasn't propositionally truncated, we could define
$p \vdash a \sim_{\El} b$ by extracting the relation out of the first component
of $p$, and apply it to $a, b$. That is, $p \vdash a \sim_{\El} b :\equiv
\pi_1\,p\,a\,b$. This would make the definition of $\_\sim_\setoidU\_$ and
$\_\vdash\_\sim_{\El}\_$ in line with how we defined $\setoidU$ and $\El$.

However, this doesn't work in our case, since the type of $p$ \emph{is}
propositionally truncated, hence it cannot be eliminated to construct a
proof-relevant object.
%
Fortunately, we can work around this limitation by defining $p \vdash x
\sim_{\El} y$ by induction on the codes $A\ B : \setoidU$, in a way that ends
up being logically equivalent to the proposition we would have obtained by
$\ad{proj}_1\ p\ x\ y$ if there were no truncation.
%
More precisely, we need to construct proofs that for any concrete $R$ and
$\ad{inR}$, the types $| (R, \ad{inR}) | \vdash x \sim_{\El} y$ and $R\ x\ y$
are logically equivalent. These in turn need to be defined mutually with
$\_\vdash\_\sim_{\El}\_$. We direct the interested reader to the Agda
formalization for the full details of these definitions, as they are quite
involved.

The full definition of the universe is concluded with the remaining definitions,
like $\reflu, \reflel$, etc., which can be adapted from their IR counterparts
more or less straighforwardly. The final result does not use
induction-recursion, but it's nevertheless an instance of infinitary
induction-induction. The ability to define arbitrary, infinitary
inductive-inductive types clashes, again, with our objective of keeping the
metatheory as small and simple as possible. The next step is therefore to reduce
this inductive-inductive universe to one that does not require (infinitary)
induction-induction.

\section{Inductive universe (maybe?)}

\subsection{Reducing finitary induction-induction}

It is known that finitary inductive-inductive definitions can be reduced to
inductive families \cite{iit-erasure,iit-to-ix,induction-is-enough}.
%
To illustrate the idea, let us consider a well-known example of finitary
inductive-inductive type, the intrinsic encoding of type theory in type theory
itself. Actually, we only need to consider the type of contexts $\textsf{Con} :
\mType$ and the type of types $\textsf{Ty} : \textsf{Con} \to \mType$; since the
latter is indexed over the former, this is already an example of
induction-induction.

Contexts in \textsf{Con} are formed out of empty contexts $\bullet$ and context
extension $\_,\_$. Types in \textsf{Ty} are either the base type $\iota$ or
$\Pi$ types.

\begin{align*}
  & \bullet : \textsf{Con} \\
  & \_,\_ : (\GG : \textsf{Con}) \to \textsf{Ty}\ \GG \to \textsf{Con} \\
  & \iota : (\GG : \textsf{Con}) \to \textsf{Ty}\ \GG \\
  & \Pi : \{\GG : \textsf{Con}\} (A : \textsf{Ty}\ \GG) \to \textsf{Ty}\ (\GG , A) \to \textsf{Ty}\ \GG
\end{align*}

The general method to eliminate induction-induction is to split the original
inductive-inductive types into a type of codes and an associated well-formedness
predicate. In our \textsf{Con/Ty} example, these would be respectively given by
codes $\textsf{Con}_0, \textsf{Ty}_0 : \mType$ and predicates $\textsf{Con}_1 :
\textsf{Con}_0 \to \mType, \textsf{Ty}_1 : \textsf{Con}_0 \to \textsf{Ty}_0 \to
\mType$.

The definition of the codes and predicate types follows that of the original
inductive-inductive type, and can be derived systematically from it. More
importantly, they can be defined without induction-induction, since although
$\textsf{Con}_0$ and $\textsf{Ty}_0$ are defined mutually, their sorts are not
indexed.

\begin{align*}
  & \bullet_0 : \textsf{Con}_0 \\
  & \_,_0\_ : (\GG : \textsf{Con}_0) \to \textsf{Ty}_0 \to \textsf{Con}_0 \\
  & \iota_0 : (\GG : \textsf{Con}_0) \to \textsf{Ty}_0 \\
  & \Pi_0 : \textsf{Con}_0 \to \textsf{Ty}_0 \to \textsf{Ty}_0 \to \textsf{Ty}_0 \\
  & \bullet_1 : \textsf{Con}_1\ \bullet_0 \\
  & \_,_1\_ : \forall\{\GG_0\ A_0\} \to \textsf{Con}_1\ \GG_0 \to \textsf{Ty}_1\ \GG_0\ A_0 \to \textsf{Con}_1\ (\GG_0 \,,_0 A_0) \\
  & \iota_1 : \forall\{\GG_0\} \to \textsf{Con}_1\ \GG_0 \to \textsf{Ty}_1\ \GG_0\ (\iota_0\ \GG_0) \\
  & \Pi_1 : \forall\{\GG_0\ A_0\ B_0\} \to \textsf{Con}_1\ \GG_0 \to \textsf{Ty}_1\ \GG_0\ A_0 \to \textsf{Ty}_1\ (\GG_0\, ,_0 A_0)\ B_0 \to \textsf{Ty}_1\ \GG_0\ (\Pi_0\ \GG_0\ A_0\ B_0)
\end{align*}

We can recover the original inductive-inductive type as $\textsf{Con} :\equiv
\Sigma (\GG_0 : \textsf{Con}_0)(\textsf{Con}_1\ \GG_0)$ and $\textsf{Ty}\ \GG
:\equiv \Sigma(A_0 :
\textsf{Ty}_0)(\textsf{Ty}_1\ (\pi_1\ \GG)\ A_0)$. Recovering the constructors
is straighforward:

\begin{align*}
  & \bullet :\equiv (\bullet_0 , \bullet_1) \\
  & (\GG_0 , \GG_1) , (A_0 , A_1) :\equiv ((\GG_0 ,_0 A_0) , (\GG_1 ,_1 A_1)) \\
  & \iota\ (\GG_0 , \GG_1) :\equiv (\iota_0 \GG_0 , \iota_1\ \GG_1) \\
  & \Pi\ \{\GG_0 , \GG_1\}(A_0 , A_1) (B_0 , B_1) :\equiv
    ((\Pi_0\ \GG_0\ A_0\ B_0) , (\Pi_1\ \GG_1\ A_1\ B_1))
\end{align*}

Finally, we can define eliminators/induction principles for $\textsf{Con}$ and
$\textsf{Ty}$ as just defined, by induction on the well-typing predicates.

For any inductive-inductive type $A : \mType, B: A \to \mType$, the most general
form of (dependent) eliminator is given by motives $F : A \to \mType$ and $G :
(a : A) \to (b : B a) \to F\ a \to \mType$, and the functions $\textsf{elim}_A :
(a : A) \to F\ a, \textsf{elim}_B : (a : A) \to (b : B\ a) \to
G\ a\ b\ (\textsf{elim}_A\ a)$. A simpler notion of eliminator does not require
the second component of the motive to mention the first. In particular, we have
$F : A \to \mType$, $G : (a : A) \to B\ a \to \mType$, and eliminators
$\textsf{elim}_A : (a : A) \to F\ a, \textsf{elim}_B : (a : A) (b : B\ a) \to
G\ a\ b$. Note that this elimination principle---that we call \emph{simple
  elimination} after [cite]---is no longer recursive-recursive, since
$\textsf{elim}_A$ is not mentioned in the signature of $\textsf{elim}_B$.

\subsection{Reducing the setoid universe}

The reduction described in the previous section works generically for an
arbitrary finitary inductive-inductive type, thus giving a systematic way to
reduce finitary inductive-inductive definitions to inductive families. However,
it is not clear whether this method extends to infinitary induction-induction,
of which the setoid universe defined in Section~\ref{?} is an instance.
%
Of course, the absence of a general reduction method does not mean that
particular concrete instances of infinitary induction-induction cannot be
reduced to simpler principles, which is exactly what we hope for our universe
construction.

The obvious challenge in successfully completing this reduction is to avoid the
need for extensionality in the metatheory. In fact, consider the simple
infinitary inductive-inductive type obtained from the previous $\textsf{Con/Ty}$
example by replacing the finitary constructor $\Pi$ with an infinitary one: $\Pi
: \{\GG : \textsf{Con}\} \to (\mathds{N} \to \textsf{Ty}\ \GG) \to
\textsf{Ty}\ \GG$. Already with this simple example, we run into problems as
soon as we try to define the general eliminator, since it requires function
extensionality. \todo{Is this true?}

Luckily, in our case we can take advantage of our specific circumstances. First
of all, we can define the well-typing predicates as $\mProp$-valued families,
rather than in $\mType$; without this, we would need function extensionality to
prove that the predicates are propositions (with respect to propositional
equality).

\begin{align*}
  & \textsf{data}\ \ad{in-U}_0 : \mType \to \mType_1 \\
  & \textsf{data}\ \ad{in-U∼}_0 : \{A\ A' : \mType\} \to (A \to A' \to \mProp) \to \mType_1 \\
  & \textsf{data}\ \ad{in-U}_1 : (A : \mType) \to \ad{in-U}_0\ A \to \mProp_1 \\
  & \textsf{data}\ \ad{in-U∼}_1 : \{A\ A' : \mType\} \to (R : A \to A' \to \mProp) \to \ad{in-U∼}_0\ R \to \mType_1
\end{align*}
\todo{check that these signatures are correct}

Using $\mProp$ would help only to some extent if we had to define general
recursive-recursive eliminators, since that would also require
extensionality. However, it turns out that for our limited use of this
inductive-inductive universe the \emph{simple} elimination principle is
sufficient. This eliminator can be defined by simple pattern matching, and does
not require extensionality.


\section{Further work}\label{further-work}

TODO

\bibliographystyle{alpha}
\bibliography{bibliography}

\end{document}
